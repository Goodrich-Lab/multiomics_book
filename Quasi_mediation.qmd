# Integrated/Quasi-Mediation {#sec-quasi}

**Exposure (G): Hg (Mercury)**

**Omics (Z): Methylation (CpG), Transcriptome, miRNA**

**Outcome (Y): MAFLD (Metabolic Associatied Fatty Liver Disease)**

First, we need to set up the project, and then we'll implement three LUCID different models to conduct the Integrated/Quasi-Mediation analysis.

```{r lucid early integration setup, include = FALSE, echo = FALSE}
source(fs::path(here::here(),"project_setup","directories.R"))
source(fs::path(dir_proj,"libraries.R"))
source(fs::path(dir_proj,"load_simu_data.R"))
source(fs::path(dir_proj,"functions", "load_functions.R"))
source(fs::path(dir_proj,"functions", "lucid_reorder_plot_without_y.R"))
source(fs::path(dir_proj,"functions", "LUCIDus Early Integration Sankey fxn.R"))
source(fs::path(dir_proj,"functions", "LUCIDus", "dependency.R"))

# For some reason, knitr version 1.42 is required in order to be compatible with htmlwidgets when rendering
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.height= 15, fig.width= 12,collapse = TRUE)
```

## *Early integration*

In the Early Integration LUCID model, genomic/exposomic exposures $G$, other omics data $Z$ and phenotype trait $Y$ are integrated through a latent categorical variable $X$. Because $X$ is an unobserved categorical variable, each category of $X$ is interpreted as a latent cluster in the data, jointly defined by $G$, $Z$ and $Y$. Let $G$ be a $N \times P$ matrix with columns representing genetic/environmental exposures, and rows representing the observations; $Z$ be a $N \times M$ matrix of omics data (for example, gene expression data, DNA methylation profiles and metabolomic data etc.) and $Y$ be a $N$-length vector of phenotype trait. We further assume $G$, $Z$ and $Y$ are measured through a prospective sampling procedure so we do not model the distribution of $G$. All three measured components ($G$, $Z$ and $Y$) are linked by a latent variable $X$ consisting of $K$ categories. The distributions of $X$ given $G$, $Z$ given $X$ and $Y$ given $X$ are conditionally independent with each other. Let $f(\cdot)$ denote the probability mass functions (PMF) for categorical random variables or the probability density functions (PDF) for continuous random variables. The joint log-likelihood of the LUCID model is constructed as:

```{=tex}
\begin{equation}
    \begin{aligned}
         \log L(\bm{\Theta}) & = \sum_{i = 1}^N \log f(\bm{Z}_i, Y_i|\bm{G}_i;\bm{\Theta}) \\
         & = \sum_{i = 1}^N \log \sum_{j = 1}^K f(X_i = j| \bm{G}_i; \bm{\Theta}) f(\bm{Z}_i| X_i = j; \bm{\Theta}) f(Y_i|X_i = j; \bm{\Theta})
    \end{aligned}
    \label{eq1}
\end{equation}
```
where $\Theta$ is a generic notation for all parameters in Early Integration LUCID model. EM algorithm is implemented to estimate all parameters $\Theta$ iteratively until convergence, and $\Theta$ represents the $G$ to $X$, $X$ to $Z$, and $X$ to $Y$ associations,

We a-priori assigned the number of clusters to two. Early Integration LUCID estimates two omics specific clusters which represent an differential risks for the outcome. These omic profiles confer different risks of the outcome and represent each omics feature's contribution to the exposure-outcome association.

### Analysis: Early Integration

```{r analysis data preparation}
# Three omics layers, Methylation (CpG), Transcriptome and miRNA
omics_df_analysis <- omics_df %>% 
  dplyr::select(contains("cg"), contains("TC"), contains("hsa"))
```

When using `estimate_lucid()` to fit Early Integration LUCID model, we specify `lucid_model = "early"`, and `K` is an integer representing number of latent clusters.

```{r LUCID mod 1 early int, fig.height= 15, fig.width= 12,collapse = TRUE}
G = exposure %>%
  as.matrix()
Z = omics_df_analysis %>% 
  as.matrix()

fit1 <- estimate_lucid(lucid_model = "early",
                       G = G,
                       Z = Z,
                       Y = outcome, 
                       K = 2,
                       CoY = covs,
                       CoG = covs,
                       useY = TRUE,
                       init_par = "random",
                       family = "normal")


# Sankey Diagram
sankey_early_integration(fit1, text_size = 20)
```

### Early Integration Results

Omics profiles for each cluster determined using Early Integration LUCID.

```{r early integration omics profiles, fig.height= 10, fig.width= 10}
M_mean = as.data.frame(fit1$pars$mu)
M_mean$cluster = as.factor(1:2)
M_mean_melt = reshape::melt(M_mean, id.vars = "cluster") 
M_mean_melt <- M_mean_melt %>% 
  mutate(cluster = ifelse(cluster == 2, "High Risk", "Low Risk"))
# add color label for omics layer
M_mean_melt = M_mean_melt %>%
  mutate(color_label = case_when(str_detect(variable,  "cg") ~ "1", 
                                 str_detect(variable, "TC") ~ "2", 
                                 TRUE ~ "3"))

ggplot(M_mean_melt, aes(fill = color_label, y = value, x = variable)) +
  geom_bar(position="dodge", stat="identity") +
  ggtitle("Omics profiles for 2 latent clusters - Lucid early integration") +
  # facet_wrap(~(cluster)) +
  facet_grid(rows = vars(cluster), scales = "free_y") +
  theme(legend.position="none") +
  geom_hline(yintercept = 0) +
  xlab("") +
  theme(text = element_text(size=10),
        axis.text.x = element_text(angle = 90, vjust = 1,
                                   hjust = 1),
        plot.margin = margin(10, 10, 10, 80),
        panel.background = element_rect(fill="white"), 
        strip.background = element_rect(fill = "white"),
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),) +
  scale_fill_manual(values = c("#2fa4da", "#A77E69", "#e7b6c1"))
```

## *Intermediate integration*

In LUCID in parallel conducting intermediate integration, latent clusters $X_a$ are estimated in each omics layer separately while integrating information from the genetic/environmental exposure $G$ and the outcome $Y$ by assuming no correlations across different omics layers. Let $G$ be a $N \times P$ matrix with columns representing genetic/environmental exposures, and rows representing the observations; there is a collection of $m$ omics data, denoted by $Z_1$, . . . , $Z_a$, . . . , $Z_m$ with corresponding dimensions $p_1$, . . . , $p_a$, . . . , $p_m$. Each omic data $Z_a$ is summarized by a latent categorical variable $X_a$, which contains $K_a$ categories. Each category is interpreted as a latent cluster (or subgroup) for that particular omic layer and $Y$ be a $N$-length vector of phenotype trait. Let $D$ be the generic notation for all observed data. The log likelihood of LUCID with multiple latent variables is constructed below,

```{=tex}
\begin{aligned}
l(\boldsymbol{\Theta} \mid \boldsymbol{D}) & =\sum_{i=1}^{n} \log f\left(\boldsymbol{Z}_{1 i}, \ldots, \boldsymbol{Z}_{m i}, \boldsymbol{Y}_{i} \mid \boldsymbol{G}_{i} ; \boldsymbol{\Theta}\right) \\
& =\sum_{i=1}^{n} \log \left[\prod_{j_{1}=1}^{k_{1}} \cdots \prod_{j_{m}=1}^{k_{m}} f\left(\boldsymbol{Z}_{1 i}, \ldots, \boldsymbol{Z}_{m i}, X_{1 i}, \ldots, X_{m i}, Y_{i} \mid \boldsymbol{G}_{i} ; \boldsymbol{\Theta}\right)^{I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right)}\right] \\
& =\sum_{i=1}^{n} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log f\left(\boldsymbol{Z}_{1 i}, \ldots, \boldsymbol{Z}_{m i}, X_{1 i}, \ldots, X_{m i}, Y_{i} \mid \boldsymbol{G}_{i} ; \boldsymbol{\Theta}\right) \\
& =\sum_{i=1}^{n} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log \phi\left(Y_{i} \mid X_{1 i}, \ldots, X_{m i}, \boldsymbol{\delta}, \sigma^{2}\right) \\
& +\sum_{i=1}^{n} \sum_{a=1}^{m} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log \phi\left(\boldsymbol{Z}_{a i} \mid X_{a i}=j_{a}, \boldsymbol{\mu}_{a, j_{a}}, \boldsymbol{\Sigma}_{a, j_{a}}\right) \\
& +\sum_{i=1}^{n} \sum_{a=1}^{m} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log S\left(\boldsymbol{X}_{a i}=j_{a} \mid \boldsymbol{G}_{i}, \boldsymbol{\beta}_{a}\right)
\end{aligned}
```
The log likelihood of LUCID in parallel is similar to that with Early integration LUCID. It is natural to follow the same principles of EM algorithm for Early integration LUCID with single intermediate variable.

We a-priori assigned the number of clusters for each omic layer to two. LUCID in parallel estimates omics specific clusters which represent an differential risks for the outcome within the layer. For each set of latent clusters within each omic layer, the corresponding omics profile was computed to identify the independent contribution of each omic layer to the exposure-outcome association.

Set up the project for analysis.

```{r lucid in parallel setup, include = FALSE, echo = FALSE}
source(fs::path(dir_fxn, "LUCIDusM in Parallel Sankey fxn Plotly.R"))
source(fs::path(dir_fxn, "LUCIDusM_get_pips.R"))
source(fs::path(dir_fxn, "plot_lucid_networks.R"))

knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

Prepare data for quasi-mediation analysis with LUCID in Parallel.

```{r data preparation lucid in parallel}
meta_df <- data.frame(ftr_name = c(colnames(omics_lst$methylome),
                                   colnames(omics_lst$transcriptome),
                                   colnames(omics_lst$miRNA))) %>%
  mutate(omic_layer = get_omic_layer_lowercase(ftr_name) ) %>%
  tidylog::left_join(omics_names %>% dplyr::select(-omic_layer))  %>%
  dplyr::select(ftr_name_for_plots, ftr_name, omic_layer) 

methylation_meta_df <- meta_df %>% filter(omic_layer == "methylome") %>% 
  mutate(ftr_name_for_plots =  
           case_when(ftr_name == "cg07385577" ~ "AJ011932.1_1",
                     ftr_name == "cg25823142" ~ "AJ011932.1_2",
                     TRUE ~ ftr_name_for_plots))
transcriptome_meta_df <- meta_df %>% filter(omic_layer == "transcriptome")
mirna_meta_df <- meta_df %>% filter(omic_layer == "mirna")

omics_lst_nmd_ftr <- omics_lst %>% 
  modify(., as.data.frame)

setnames(omics_lst_nmd_ftr$methylome, 
         old = c(methylation_meta_df$ftr_name), 
         new = c(methylation_meta_df$ftr_name_for_plots))

setnames(omics_lst_nmd_ftr$transcriptome, 
         old = c(transcriptome_meta_df$ftr_name),
         new = c(transcriptome_meta_df$ftr_name_for_plots))

setnames(omics_lst_nmd_ftr$miRNA, 
         old = c(mirna_meta_df$ftr_name),
         new = c(mirna_meta_df$ftr_name_for_plots))
```

### Analysis: Lucid with 3 omics layers in parallel

When using `estimate_lucid()` to fit LUCID in parallel model, we specify `lucid_model = "parallel"`, and `K` is a list with the same length as the number of omics layers and each element in the list is an integer representing number of latent clusters for the corresponding omics layer.

```{r lucid in parallel, echo=FALSE, cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE, fig.height= 15,fig.width= 12}
G = exposure %>% as.matrix()
Z = omics_lst[c(1:3)]
Y = outcome 

fit <- estimate_lucid(lucid_model = "parallel",
                      G = G, 
                      Z = Z, 
                      Y = Y,
                      K = rep(2, length(Z)), 
                      family = "normal", 
                      max_itr = 200, 
                      useY = TRUE, 
                      modelName = "EEV")

# Reorder the clusters
fit_reordered <- reorder_lucidM(fit, reference = c(1,1,2))
```

### Sankey diagram

```{r sankey diagram plotly lucid in parallel, message = FALSE, warning = FALSE,fig.height= 12, fig.width= 10}
(fig <- plot_lucid_in_parallel_plotly(fit_reordered,
                                      sankey_colors = sankey_colors,
                                      text_size = 20,
                                      n_z_ftrs_to_plot = c(7,7,7)))
```

### Omics profiles for each cluster predicted by LUCID

```{r omics profiles lucid in parellel, fig.height= 8, fig.width= 10}
M_mean = as_tibble(fit$res_Mu_Sigma$Mu[[1]], rownames = "variable") %>%
  bind_rows(as_tibble(fit$res_Mu_Sigma$Mu[[2]], rownames = "variable")) %>%
  bind_rows(as_tibble(fit$res_Mu_Sigma$Mu[[3]], rownames = "variable"))

# Reorder results because mirna order is reversed
M_mean1 <- M_mean %>% 
  bind_cols(meta_df) %>%
  mutate(`Low Risk`  =  if_else(omic_layer == "mirna", V2, V1), 
         `High Risk` =  if_else(omic_layer == "mirna", V1, V2)) %>%
  dplyr::select(-c("V1", "V2"))

# Pivot longer for figure 
M_mean_l <- M_mean1 %>% 
  pivot_longer(cols = c(`Low Risk`, `High Risk`),
               names_to = "cluster",
               values_to = "value")

# add color label for omics layer
M_mean2 = M_mean_l %>%
  mutate(color_label = case_when(omic_layer == "methylome" ~ "1", 
                                 omic_layer == "transcriptome" ~ "2", 
                                 omic_layer == "mirna" ~ "3"), 
         low_high = if_else(str_detect(cluster, "Low"), 0,1),
         omic = if_else(omic_layer == "mirna", 
                        "miR",
                        str_sub(omic_layer, end = 1) %>% toupper()),
         omic_cluster = str_c(omic, low_high))

# Filter only the top ## differential expressed features 
M_mean2_top <- M_mean2 %>% 
  group_by(variable) %>% 
  tidylog::filter(abs(value) == max(abs(value))) %>% 
  ungroup() %>% 
  arrange(max(abs(value))) %>% 
  group_by(omic_layer) %>% 
  tidylog::slice_head(n=12) %>%
  ungroup()

# Plots top 12 features
ggplot(M_mean2  %>% filter(variable %in% M_mean2_top$variable),
       aes(fill = color_label, y = value, x = variable)) +
  geom_bar(position="dodge", stat="identity") +
  ggtitle("Omics profiles for 2 latent clusters - Lucid in Parallel") +
  facet_grid(rows = vars(cluster),
             cols = vars(omic_layer), scales = "free_x", space = "free") +
  theme(legend.position="none") +
  geom_hline(yintercept = 0) +
  xlab("") +
  theme(text = element_text(size=10),
        axis.text.x = element_text(angle = 90, vjust = 1,
                                   hjust = 1),
        plot.margin = margin(10, 10, 10, 80),
        panel.background = element_rect(fill="white"),
        strip.background = element_rect(fill = "white"),
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),) +
  scale_fill_manual(values = c("#2fa4da", "#A77E69", "#e7b6c1"))
```

### Calculate PIPs and determine cluster assignment for each participant

```{r get pips}
lucid_pips <- get_pips(fit) %>% as_tibble()

# Add rownames, exposures, and outcome
lucid_pips$exposure <- exposure
lucid_pips$outcome <- outcome

# Create variable for combinations of clusters 
lucid_pips <- lucid_pips %>% 
  mutate(cluster_assignment = paste0("M", l1_pred, "_T", l2_pred, "_miR", l3_pred))
```

### Examine how cluster assignment is associated with exposures and outcomes

```{r pips with exposure and outcome}
# Association of each cluster with the exposure
exposures_per_group <- lm(exposure ~ cluster_assignment - 1, data = lucid_pips) %>%
  tidy(conf.int = TRUE) %>%
  mutate(term = str_remove(term, "cluster_assignment"),
         exp_out = "exposure")  %>%
  rename(cluster_assignment = term)

# Association of each cluster with the outcome
outcomes_per_group <- lm(outcome ~ cluster_assignment - 1, data = lucid_pips) %>%
  tidy(conf.int = TRUE) %>% 
  mutate(term = str_remove(term, "cluster_assignment"), 
         exp_out = "outcome")  %>%
  rename(cluster_assignment = term)

# Combine Exposures and outcomes
exp_out_by_group <- bind_rows(exposures_per_group, outcomes_per_group)

# Get sample size per cluster 
lucid_clusters_sample_size <- lucid_pips %>% 
  group_by(cluster_assignment) %>%
  summarise(n = length(cluster_assignment)) %>% 
  ungroup()

# Combine PIPs with sample size per cluster 
lucid_clusters <- lucid_clusters_sample_size %>%
  tidylog::left_join(exp_out_by_group) %>% 
  mutate(m = str_sub(cluster_assignment, end = -9), 
         t = str_sub(cluster_assignment, start = 4, end = 5),
         p = str_sub(cluster_assignment, start = 7)) %>%
  dplyr::select(m, t, p, everything()) %>%
  janitor::clean_names()

# Make group names
lucid_clusters <- lucid_clusters %>% 
  mutate(
    group_name = case_when(
      cluster_assignment == "M0_T0_miR1" ~ "Group 1",
      cluster_assignment == "M0_T1_miR1" ~ "Group 2",
      cluster_assignment == "M0_T0_miR0" ~ "Group 3",
      cluster_assignment == "M0_T1_miR0" ~ "Group 4",
      cluster_assignment == "M1_T0_miR1" ~ "Group 5",
      cluster_assignment == "M1_T1_miR0" ~ "Group 6",
      cluster_assignment == "M1_T0_miR0" ~ "Group 7",
      cluster_assignment == "M1_T1_miR1" ~ "Group 8"))


# Pivot wider on exposures and outcomes
lucid_clusters_w <- lucid_clusters %>%
  tidylog::pivot_wider(names_from = "exp_out", 
                       values_from = c(estimate:conf_high))


# Visualize clusters by exposure and outcome levels
ggplot(lucid_clusters_w, 
       aes(x = estimate_exposure, y = estimate_outcome, 
           label = group_name)) + 
  geom_text() +
  ggrepel::geom_label_repel(aes(label = cluster_assignment)) 

# Combine individual level data with summary data 
lucid_pips_fin <- lucid_pips %>% 
  tidylog::left_join(lucid_clusters_w)
```

### Visualize Omics Profiles

```{r visualize profiles}
## MAKE omics profiles for each of the 8 clusters 
top_ftrs <- M_mean2 %>% filter(variable %in% M_mean2_top$variable)

# Order omic layers
top_ftrs <- top_ftrs %>% 
  mutate(omic_layer = fct_relevel(omic_layer, 
                                  c("methylome", "mirna", "transcriptome")), 
         omic_cluster_named = paste(cluster, str_to_title(omic_layer))) %>%
  arrange(omic_layer) %>% 
  mutate(omic_cluster_named = fct_inorder(omic_cluster_named))


# Sort by the magnitude of association with high risk cluster
top_ftrs <- top_ftrs %>% 
  arrange(-low_high) %>% 
  group_by(variable) %>%
  mutate(high_risk_value = value[1]) %>%
  ungroup() %>%
  arrange(omic_cluster_named, high_risk_value) %>% 
  mutate(variable = fct_inorder(variable))

# Plot omics profile ----
omics_profile_plot <- function(clusters_to_include, 
                               vjust = 0, 
                               text_size = 4.5){
  ggplot(top_ftrs %>% filter(omic_cluster %in% clusters_to_include), 
         aes(fill = color_label, x = value, y = fct_rev(variable))) +
    geom_bar(position="dodge", stat="identity") + #, color = "white"
    geom_vline(xintercept = 0, color = "grey50") +
    xlim(c(-1.16, 2.11)) + # MODIFY THIS TO ALIGN WITH EXPOSURE/OUTCOME FIGURE -------------
  xlab(NULL) + ylab(NULL) +
    theme(legend.position="none", 
          text = element_text(size=10),
          # axis.text.x = element_text(angle = 90, vjust = 1,hjust = 1),
          strip.background = element_rect(fill = "white"), 
          axis.line = element_blank(), 
          strip.text = element_blank(),
          axis.ticks = element_blank(), 
          axis.text = element_blank()) +
    scale_fill_manual(values = c(col_pal[1], col_pal[2], col_pal[3])) +  #2fa4da 
    annotate(geom = "text", 
             x = ifelse(clusters_to_include[1] == "M1", 0.02,-0.89), 
             y = 22, ## y position
             hjust = 0, 
             vjust = vjust,
             label = paste("Methylation\nProfile", 
                           str_sub(clusters_to_include[1], -1)),
             lineheight = 0.75, color = col_pal[1], size = text_size) + 
    annotate(geom = "text",  
             x = ifelse(clusters_to_include[3] == "miR1", 0.02,-0.89), 
             y = 10, ## y position
             hjust = 0, 
             vjust = vjust+.1,
             label = paste("miRNA\nProfile ",  
                           str_sub(clusters_to_include[3], -1)),
             lineheight = 0.75, color = col_pal[3], size = text_size) +
    annotate(geom = "text",  x = -0.89, y = 0, ## y position
             hjust = 0, 
             vjust = vjust+.5,
             label = paste("Transcript\nProfile", 
                           str_sub(clusters_to_include[2], -1)),
             lineheight = 0.75, color = col_pal[2], size = text_size)
}

vjust_profile_nms <- -.9
gp1_omics = omics_profile_plot(c("M0", "T0", "miR1"), vjust = vjust_profile_nms)
gp2_omics = omics_profile_plot(c("M0", "T1", "miR1"), vjust = vjust_profile_nms)
gp3_omics = omics_profile_plot(c("M0", "T0", "miR0"), vjust = vjust_profile_nms)
gp4_omics = omics_profile_plot(c("M0", "T1", "miR0"), vjust = vjust_profile_nms)
gp5_omics = omics_profile_plot(c("M1", "T0", "miR1"), vjust = vjust_profile_nms)
gp6_omics = omics_profile_plot(c("M1", "T1", "miR0"), vjust = vjust_profile_nms)
gp7_omics = omics_profile_plot(c("M1", "T0", "miR0"), vjust = vjust_profile_nms)
gp8_omics = omics_profile_plot(c("M1", "T1", "miR1"), vjust = vjust_profile_nms)

# Exposure and outcome bargraph by cluster
group_to_plot <- "Group 1"
exposure_plot_fxn  <- function(group_to_plot, text_just = -.15, size = 4.7) {
  ( base_plot <- ggplot(lucid_clusters %>% 
                          filter(group_name == group_to_plot) %>% 
                          mutate(estimate = if_else(estimate>1.3, 1.3, estimate)),
                        aes(y = fct_rev(str_to_sentence(exp_out)),
                            x = estimate,
                            fill = exp_out, 
                            label = if_else(exp_out == "outcome", "Outcome", "Exposure"))) +
      geom_bar(stat = "identity", color = "black", width = 1.1) + 
      geom_vline(xintercept = 0, color = "grey50") +
      geom_text(aes(x = if_else(estimate < 0, estimate, 0)), 
                hjust=1.05, size = size, fontface = "italic") +
      scale_fill_manual(values = c(sankey_colors$range[sankey_colors$domain == "exposure"], 
                                   sankey_colors$range[sankey_colors$domain == "Outcome"])) +
      facet_wrap(~exp_out, ncol = 1, scales = "free_y") +
      xlim(c(-1.1, 2.1)) + # MODIFY HERE TO ALIGN ---------
    theme_void() + 
      theme(legend.position = "none", axis.text = element_blank(),
            axis.title = element_blank(), strip.text = element_blank())) 
}  

# Exposure 
eo_figs <- purrr::map(unique(lucid_clusters$group_name),
                      .f = exposure_plot_fxn)
names(eo_figs) <- unique(lucid_clusters$group_name)

# Combine
(profile_fig <- plot_grid(
  NULL, NULL, eo_figs[["Group 1"]], eo_figs[["Group 5"]], gp1_omics, gp5_omics,   
  NULL, NULL, eo_figs[["Group 2"]], eo_figs[["Group 6"]], gp2_omics, gp6_omics,   
  NULL, NULL, eo_figs[["Group 3"]], eo_figs[["Group 7"]], gp3_omics, gp7_omics,  
  NULL, NULL, eo_figs[["Group 4"]], eo_figs[["Group 8"]], gp4_omics, gp8_omics,  
  ncol = 2,
  label_size = 16,
  label_fontface = "bold",
  vjust = 1.2,
  rel_heights = rep(c(.17,.22,1), 4),
  align = "v",
  axis = "lv",
  labels = c("Group 1", "Group 5", rep("", 4),
             "Group 2", "Group 6", rep("", 4),
             "Group 3", "Group 7", rep("", 4),
             "Group 4", "Group 8", rep("", 4))))
```


## *Late Integration*

For late integration, LUCID in serial is implemented, which successively links multiple single omics LUCID models using the Early Integration LUCID model. Let $G$ be a $N \times P$ matrix with columns representing genetic/environmental exposures, and rows representing the observations; there is an ordered collection of $m$ omics data, denoted by $Z_1$, . . . , $Z_a$, . . . , $Z_m$ with corresponding dimensions $p_1$, . . . , $p_a$, . . . , $p_m$. Successive omics layers $Z_a$ are linked by using each observations' posterior inclusion probability (PIP) for latent clusters $X_a$ in the initial LUCID model to be the "exposure" variable for each successive model. The omic layers are ordered in a sequential fashion based on the biological relationships between omic layers. For the first model, an unsupervised Early Integration LUCID model using $G$ as the exposure and $Z_1$ as the omics layer. The PIPs of the non-reference clusters were extracted and used as the input for the exposure for the following unsupervised Early Integration LUCID model. This procedure is iterated until the last omics layer $Z_m$, for which a supervised Early Integration LUCID model is used to conduct integrated clustering while using PIPs from the previous LUCID model and information on the outcome $Y$.

```{r lucid in serial setup, include = FALSE, echo = FALSE}
source(fs::path(dir_proj, "functions","LUCIDusM in Serial Sankey fxn.R"))
```

### Step 1. Hg + Methylation

When using `estimate_lucid()` to fit LUCID in serial model, we specify `lucid_model = "serial"`, and `K` is a list with the same length as the number of ordered omics layers and each element in the list is an integer representing number of latent clusters for the corresponding omics layer.

```{r LUCID model 1}
set.seed(100)
G_Hg = exposure %>% as.matrix()
Z = list(omics_lst$methylome,
         omics_lst$transcriptome,
         omics_lst$miRNA)
Y_liv_inj = scale(outcome)

fit <- estimate_lucid(lucid_model = "serial",
                      G = G_Hg,
                      Z = Z,
                      Y = Y_liv_inj, 
                      CoY = covs,
                      CoG = covs,
                      K = list(2,2,2),
                      useY = TRUE,
                      init_par = "random",
                      family = "normal", 
                      Rho_Z_Mu = 10,
                      Rho_Z_Cov = .3)

fit1 <- fit$submodel[[1]]
# Rename Exposure
fit1$var.names$Gnames[1] <- "Hg"
fit2 <- fit$submodel[[2]]
fit2$var.names$Gnames[1] <- "<b>Methylation\nProfile 1</b>"
fit3 <- fit$submodel[[3]]
fit3$var.names$Gnames[1] <- "<b>miRNA\nProfile 1</b>"
```

### Sankey Diagram

```{r Sankey Diagram lucid in serial, fig.height= 15, fig.width= 12}
col_pal <- RColorBrewer::brewer.pal(n = 8, name = "Dark2")
color_pal_sankey <- matrix(c("exposure", "red",
                             "lc",       "#b3d8ff",
                             "TC",      col_pal[2],
                             "CpG",       col_pal[1],
                             "miRNA",  col_pal[3],
                             "outcome",  "grey"), 
                           ncol = 2, byrow = TRUE) %>%
  as_tibble(.name_repair = "unique") %>% 
  janitor::clean_names() %>%
  dplyr::rename(group = x1, color = x2)

sankey_in_serial(fit1, 
                 fit2, 
                 fit3, 
                 color_pal_sankey,
                 text_size = 24)
```

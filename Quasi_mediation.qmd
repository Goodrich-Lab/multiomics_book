# Integrated/Quasi-Mediation {#sec-quasi}

**Exposure (G): Hg (Mercury)**

**Omics (Z): Methylation (CpG), Transcriptome, miRNA**

**Outcome (Y): MAFLD (Metabolic Associatied Fatty Liver Disease)**

First, we need to set up the project, and then we'll implement three LUCID different models to conduct the Integrated/Quasi-Mediation analysis.

```{r lucid early integration setup, include = FALSE, echo = FALSE}
source(fs::path(here::here(),"project_setup","directories.R"))
source(fs::path(dir_proj,"libraries.R"))
source(fs::path(dir_proj,"load_simu_data.R"))
# source(fs::path(dir_proj,"functions", "load_functions.R"))
source(fs::path(dir_proj,"functions", "lucid_reorder_plot_without_y.R"))
source(fs::path(dir_proj,"functions", "LUCIDus Early Integration Sankey fxn.R"))
source(fs::path(dir_proj,"functions", "LUCIDus", "dependency.R"))

# For some reason, knitr version 1.42 is required in order to be compatible with htmlwidgets when rendering
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.height= 15, fig.width= 12,collapse = TRUE)
```

## *Early Integration*

In the Early Integration LUCID model, genomic/exposomic exposures $G$, other omics data $Z$ and phenotype trait $Y$ are integrated through a latent categorical variable $X$. Because $X$ is an unobserved categorical variable, each category of $X$ is interpreted as a latent cluster in the data, jointly defined by $G$, $Z$ and $Y$. Let $G$ be a $N \times P$ matrix with columns representing genetic/environmental exposures, and rows representing the observations; $Z$ be a $N \times M$ matrix of omics data (for example, gene expression data, DNA methylation profiles and metabolomic data etc.) and $Y$ be a $N$-length vector of phenotype trait. We further assume $G$, $Z$ and $Y$ are measured through a prospective sampling procedure so we do not model the distribution of $G$. All three measured components ($G$, $Z$ and $Y$) are linked by a latent variable $X$ consisting of $K$ categories. The distributions of $X$ given $G$, $Z$ given $X$ and $Y$ given $X$ are conditionally independent with each other. Let $f(\cdot)$ denote the probability mass functions (PMF) for categorical random variables or the probability density functions (PDF) for continuous random variables. The joint log-likelihood of the LUCID model is constructed as:

$$
\begin{aligned}
         \log L({\Theta}) & = \sum_{i = 1}^N \log f({Z}_i, Y_i|{G}_i;{\Theta}) \\
         & = \sum_{i = 1}^N \log \sum_{j = 1}^K f(X_i = j|{G}_i;{\Theta}) f({Z}_i| X_i = j; {\Theta}) f(Y_i|X_i = j; {\Theta})
    \end{aligned}
$$ where $\Theta$ is a generic notation for all parameters in Early Integration LUCID model. EM algorithm is implemented to estimate all parameters $\Theta$ iteratively until convergence, and $\Theta$ represents the $G$ to $X$, $X$ to $Z$, and $X$ to $Y$ associations,

We a-priori assigned the number of clusters to two. Early Integration LUCID estimates two omics specific clusters which represent an differential risks for the outcome. These omic profiles confer different risks of the outcome and represent each omics feature's contribution to the exposure-outcome association.

### Analysis: Early Integration

```{r analysis data preparation}
# Three omics layers, Methylation (CpG), Transcriptome and miRNA
omics_df_analysis <- omics_df %>% 
  dplyr::select(contains("cg"), contains("TC"), contains("miR"))
```

When using `estimate_lucid()` to fit the Early Integration LUCID model, we specify `lucid_model = "early"`, and `K` is an integer representing number of latent clusters. `G`, `Z`, `Y` are the inputs for exposure, omics data matrix, and the outcome, respectively.`CoY` are the covariates to be adjusted for the $X$ to $Y$ association and `CoG` are the covariates to be adjusted for the $G$ to $X$ association. We specify `useY = TRUE` to construct supervised LUCID model. Otherwise, `useY = FALSE` will construct unsupervised LUCID model. `init_par = "random"` means that we initiate the parameters with random guess. We specify `family = "normal"` since the outcome is continuous. If the outcome is binary, we would specify `family = "binary"`.

```{r LUCID mod 1 early int, fig.height= 15, fig.width= 12,collapse = TRUE}
G = exposure %>%
  as.matrix()
Z = omics_df_analysis %>% 
  as.matrix()

fit1 <- estimate_lucid(lucid_model = "early",
                       G = G,
                       Z = Z,
                       Y = outcome, 
                       K = 2,
                       CoY = covs,
                       CoG = covs,
                       useY = TRUE,
                       init_par = "random",
                       family = "normal")

# Sankey Diagram
p1 <- sankey_early_integration(fit1, text_size = 20)

```

![The Sankey Diagram for LUCID (Early Integration).](lucid_early.png){#fig-l_early}

### Early Integration Results

Omics profiles for each cluster determined using Early Integration LUCID.

```{r early integration omics profiles, fig.height= 10, fig.width= 10}
M_mean = as.data.frame(fit1$pars$mu)
M_mean$cluster = as.factor(1:2)

# Reshape the data
M_mean_melt <- M_mean %>% 
  pivot_longer(cols = -cluster, names_to = "variable", values_to = "value")

M_mean_melt <- M_mean_melt %>% 
  mutate(cluster = ifelse(cluster == 2, "High Risk", "Low Risk"))
# add color label for omics layer
M_mean_melt = M_mean_melt %>%
  mutate(color_label = case_when(str_detect(variable,  "cg") ~ "1", 
                                 str_detect(variable, "TC") ~ "2", 
                                 TRUE ~ "3"))

ggplot(M_mean_melt, aes(fill = color_label, y = value, x = variable)) +
  geom_bar(position="dodge", stat="identity") +
  ggtitle("Omics profiles for 2 latent clusters - Lucid early integration") +
  # facet_wrap(~(cluster)) +
  facet_grid(rows = vars(cluster), scales = "free_y") +
  theme(legend.position="none") +
  geom_hline(yintercept = 0) +
  xlab("") +
  theme(text = element_text(size=10),
        axis.text.x = element_text(angle = 90, vjust = 1,
                                   hjust = 1),
        plot.margin = margin(10, 10, 10, 80),
        panel.background = element_rect(fill="white"), 
        strip.background = element_rect(fill = "white"),
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),) +
  scale_fill_manual(values = c("#2fa4da", "#A77E69", "#e7b6c1"))
```

## *Intermediate Integration*

In LUCID in parallel conducting intermediate integration, latent clusters $X_a$ are estimated in each omics layer separately while integrating information from the genetic/environmental exposure $G$ and the outcome $Y$ by assuming no correlations across different omics layers. Let $G$ be a $N \times P$ matrix with columns representing genetic/environmental exposures, and rows representing the observations; there is a collection of $m$ omics data, denoted by $Z_1$, . . . , $Z_a$, . . . , $Z_m$ with corresponding dimensions $p_1$, . . . , $p_a$, . . . , $p_m$. Each omics data $Z_a$ is summarized by a latent categorical variable $X_a$, which contains $K_a$ categories. Each category is interpreted as a latent cluster (or subgroup) for that particular omics layer and $Y$ be a $N$-length vector of phenotype trait. Let $D$ be the generic notation for all observed data. The log likelihood of LUCID with multiple latent variables is constructed below,

$$
\begin{aligned}
l(\boldsymbol{\Theta} \mid \boldsymbol{D}) & =\sum_{i=1}^{n} \log f\left(\boldsymbol{Z}_{1 i}, \ldots, \boldsymbol{Z}_{m i}, \boldsymbol{Y}_{i} \mid \boldsymbol{G}_{i} ; \boldsymbol{\Theta}\right) \\
& =\sum_{i=1}^{n} \log \left[\prod_{j_{1}=1}^{k_{1}} \cdots \prod_{j_{m}=1}^{k_{m}} f\left(\boldsymbol{Z}_{1 i}, \ldots, \boldsymbol{Z}_{m i}, X_{1 i}, \ldots, X_{m i}, Y_{i} \mid \boldsymbol{G}_{i} ; \boldsymbol{\Theta}\right)^{I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right)}\right] \\
& =\sum_{i=1}^{n} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log f\left(\boldsymbol{Z}_{1 i}, \ldots, \boldsymbol{Z}_{m i}, X_{1 i}, \ldots, X_{m i}, Y_{i} \mid \boldsymbol{G}_{i} ; \boldsymbol{\Theta}\right) \\
& =\sum_{i=1}^{n} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log \phi\left(Y_{i} \mid X_{1 i}, \ldots, X_{m i}, \boldsymbol{\delta}, \sigma^{2}\right) \\
& +\sum_{i=1}^{n} \sum_{a=1}^{m} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log \phi\left(\boldsymbol{Z}_{a i} \mid X_{a i}=j_{a}, \boldsymbol{\mu}_{a, j_{a}}, \boldsymbol{\Sigma}_{a, j_{a}}\right) \\
& +\sum_{i=1}^{n} \sum_{a=1}^{m} \sum_{j_{1}=1}^{k_{1}} \ldots \sum_{j_{m}=1}^{k_{m}} I\left(X_{1 i}=j_{1}, \ldots, X_{m i}=j_{m}\right) \log S\left(\boldsymbol{X}_{a i}=j_{a} \mid \boldsymbol{G}_{i}, \boldsymbol{\beta}_{a}\right)
\end{aligned}
$$

The log likelihood of LUCID in parallel is similar to that with Early integration LUCID. It is natural to follow the same principles of EM algorithm for Early integration LUCID with single intermediate variable.

We a-priori assigned the number of clusters for each omic layer to two. LUCID in parallel estimates omics specific clusters which represent an differential risks for the outcome within the layer. For each set of latent clusters within each omics layer, the corresponding omics profile was computed to identify the independent contribution of each omics layer to the exposure-outcome association.

Set up the project for analysis.

```{r lucid in parallel setup, include = FALSE, echo = FALSE}
source(fs::path(dir_fxn, "LUCIDusM in Parallel Sankey fxn Plotly.R"))
source(fs::path(dir_fxn, "LUCIDusM_get_pips.R"))
source(fs::path(dir_fxn, "plot_lucid_networks.R"))

knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

Prepare data for quasi-mediation analysis with LUCID in Parallel.

```{r data preparation lucid in parallel}
# get feature meta data
omics_lst_df <- purrr::map(omics_lst, ~as_tibble(.x))
  
meta_df <- imap_dfr(omics_lst_df, ~tibble(omic_layer = .y, ftr_name = names(.x)))
# 
# # JG note- do we need this? ----
# meta_df <- data.frame(ftr_name = c(colnames(omics_lst$methylome),
#                                    colnames(omics_lst$transcriptome),
#                                    colnames(omics_lst$miRNA))) %>%
#   left_join(ftr_meta, by = "ftr_name")


omics_lst_nmd_ftr = omics_lst
# END NODE
```

### Analysis: Lucid with 3 omics layers in parallel

When using `estimate_lucid()` to fit LUCID in parallel model, we specify `lucid_model = "parallel"`, and `K` is a list with the same length as the number of omics layers and each element in the list is an integer representing number of latent clusters for the corresponding omics layer. `max_itr = 200` means that the algorithm will stop when the iterations reaches 200 if still not reaching convergence. We specify `useY = TRUE` to construct supervised LUCID model. `modelName` is a vector of strings specifies the geometric model of omics data, the default `modelName` is "VVV", but here "EEV" is more suitable.

```{r lucid in parallel, echo=FALSE, cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE, fig.height= 15,fig.width= 12}
G = exposure %>% as.matrix()
Z = omics_lst[c(1:3)]
Y = outcome 

fit <- estimate_lucid(lucid_model = "parallel",
                      G = G, 
                      Z = Z, 
                      Y = Y,
                      K = rep(2, length(Z)), 
                      family = "normal", 
                      max_itr = 200, 
                      useY = TRUE, 
                      modelName = "EEV")

# Reorder the clusters
fit_reordered <- reorder_lucidM(fit, reference = c(2,2,2))
```

### Sankey diagram

```{r sankey diagram plotly lucid in parallel, message = FALSE, warning = FALSE,fig.height= 12, fig.width= 10}
p2 <- plot_lucid_in_parallel_plotly(fit_reordered,
                                      sankey_colors = sankey_colors,
                                      text_size = 20,
                                      n_z_ftrs_to_plot = c(7,7,7))

```

![The Sankey Diagram for LUCID in Parallel (Intermediate Integration).](lucid_intermediate.png){#fig-l_int}

### Omics profiles for each cluster predicted by LUCID

```{r omics profiles lucid in parellel, fig.height= 8, fig.width= 10}
M_mean = as_tibble(fit$res_Mu_Sigma$Mu[[1]], rownames = "variable") %>%
  bind_rows(as_tibble(fit$res_Mu_Sigma$Mu[[2]], rownames = "variable")) %>%
  bind_rows(as_tibble(fit$res_Mu_Sigma$Mu[[3]], rownames = "variable"))

# Reorder results because mirna order is reversed
M_mean1 <- M_mean %>% 
  left_join(meta_df, by = c("variable" = "ftr_name")) %>%
  mutate(`Low Risk`  =  if_else(omic_layer == "miRna", V2, V1), 
         `High Risk` =  if_else(omic_layer == "miRna", V1, V2)) %>%
  dplyr::select(-c("V1", "V2"))

# Pivot longer for figure 
M_mean_l <- M_mean1 %>% 
  pivot_longer(cols = c(`Low Risk`, `High Risk`),
               names_to = "cluster",
               values_to = "value")

# add color label for omics layer
M_mean2 = M_mean_l %>%
  mutate(color_label = case_when(omic_layer == "methylome" ~ "1", 
                                 omic_layer == "transcriptome" ~ "2", 
                                 omic_layer == "miRna" ~ "3"), 
         low_high = if_else(str_detect(cluster, "Low"), 0,1),
         omic = if_else(omic_layer == "miRna", 
                        "miR",
                        str_sub(omic_layer, end = 1) %>% toupper()),
         omic_cluster = str_c(omic, low_high))

# Filter only the top ## differential expressed features 
M_mean2_top <- M_mean2 %>% 
  group_by(variable) %>% 
  filter(abs(value) == max(abs(value))) %>% 
  ungroup() %>% 
  arrange(max(abs(value))) %>% 
  group_by(omic_layer) %>% 
  slice_head(n=12) %>%
  ungroup()

# Plots top 12 features
ggplot(M_mean2  %>% filter(variable %in% M_mean2_top$variable),
       aes(fill = color_label, y = value, x = variable)) +
  geom_bar(position="dodge", stat="identity") +
  ggtitle("Omics profiles for 2 latent clusters - Lucid in Parallel") +
  facet_grid(rows = vars(cluster),
             cols = vars(omic_layer), scales = "free_x", space = "free") +
  theme(legend.position="none") +
  geom_hline(yintercept = 0) +
  xlab("") +
  theme(text = element_text(size=10),
        axis.text.x = element_text(angle = 90, vjust = 1,
                                   hjust = 1),
        plot.margin = margin(10, 10, 10, 80),
        panel.background = element_rect(fill="white"),
        strip.background = element_rect(fill = "white"),
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),) +
  scale_fill_manual(values = c("#2fa4da", "#A77E69", "#e7b6c1"))
```

### Calculate PIPs and determine cluster assignment for each participant

```{r get pips}
lucid_pips <- get_pips(fit) %>% as_tibble()

# Add rownames, exposures, and outcome
lucid_pips$exposure <- exposure
lucid_pips$outcome <- outcome

# Create variable for combinations of clusters 
lucid_pips <- lucid_pips %>% 
  mutate(cluster_assignment = paste0("M", l1_pred, "_T", l2_pred, "_miR", l3_pred))
```

## *Late Integration*

For late integration, LUCID in serial is implemented, which successively links multiple single omics LUCID models using the Early Integration LUCID model. Let $G$ be a $N \times P$ matrix with columns representing genetic/environmental exposures, and rows representing the observations; there is an ordered collection of $m$ omics data, denoted by $Z_1$, . . . , $Z_a$, . . . , $Z_m$ with corresponding dimensions $p_1$, . . . , $p_a$, . . . , $p_m$. Successive omics layers $Z_a$ are linked by using each observations' posterior inclusion probability (PIP) for latent clusters $X_a$ in the initial LUCID model to be the "exposure" variable for each successive model. The omics layers are ordered in a sequential fashion based on the biological relationships between omics layers. For the first model, an unsupervised Early Integration LUCID model using $G$ as the exposure and $Z_1$ as the omics layer. The PIPs of the non-reference clusters were extracted and used as the input for the exposure for the following unsupervised Early Integration LUCID model. This procedure is iterated until the last omics layer $Z_m$, for which a supervised Early Integration LUCID model is used to conduct integrated clustering while using PIPs from the previous LUCID model and information on the outcome $Y$.

```{r lucid in serial setup, include = FALSE, echo = FALSE}
source(fs::path(dir_proj, "functions","LUCIDusM in Serial Sankey fxn.R"))
```

When using `estimate_lucid()` to fit LUCID in serial model, we specify `lucid_model = "serial"`, and `K` is a list with the same length as the number of ordered omics layers and each element in the list is an integer representing number of latent clusters for the corresponding omics layer. `G`, `Z`, `Y` are the inputs for exposure, omics data matrix, and the outcome, respectively. Note that here Z is list of omics layers (vectors). `CoY` are the covariates to be adjusted for the $X$ to $Y$ association and `CoG` are the covariates to be adjusted for the $G$ to $X$ association. We specify `useY = TRUE` to construct supervised LUCID in serial model. We specify `family = "normal"` since the outcome is continuous. If the outcome is binary, we would specify `family = "binary"`. We specify `Rho_Z_Mu = 10` and `Rho_Z_Cov = .3` to use LASSO penalty to regularize cluster-specific means and variance for $Z$. We will get a selection of $Z$ features for each layer, and then we refit the LUCID in serial model with only selected $Z$ features to construct the final model.

```{r LUCID model 1}
set.seed(100)
G_Hg = exposure %>% as.matrix()
Z = list(omics_lst$methylome,
         omics_lst$transcriptome,
         omics_lst$miRNA)
Y_liv_inj = scale(outcome)

#get the selection  
fit <- estimate_lucid(lucid_model = "serial",
                      G = G_Hg,
                      Z = Z,
                      Y = Y_liv_inj, 
                      CoY = covs,
                      CoG = covs,
                      K = list(2,2,2),
                      useY = TRUE,
                      family = "normal", 
                      Rho_Z_Mu = 10,
                      Rho_Z_Cov = .3)

#extract the selected Z features to make the selected Z matrix to refit the lUCID in serial
selected_Z = vector(mode = "list", length = length(Z))
for (i in (1:length(Z))){
  fiti_select_Z = fit$submodel[[i]]$select$selectZ
  selected_Z[[i]] = Z[[i]][,fiti_select_Z]
}

#Refit ther LUCID in serial model with selected Z
fit <- estimate_lucid(lucid_model = "serial",
                      G = G_Hg,
                      Z = selected_Z,
                      Y = Y_liv_inj, 
                      CoY = covs,
                      CoG = covs,
                      K = list(2,2,2),
                      useY = TRUE,
                      init_par = "random",
                      family = "normal")

# Rename Exposure
fit1 <- fit$submodel[[1]]
fit1$var.names$Gnames[1] <- "Hg"
fit2 <- fit$submodel[[2]]
fit2$var.names$Gnames[1] <- "<b>Methylation\nProfile 1</b>"
fit3 <- fit$submodel[[3]]
fit3$var.names$Gnames[1] <- "<b>miRNA\nProfile 1</b>"
```

### Sankey Diagram

```{r Sankey Diagram lucid in serial, fig.height= 15, fig.width= 12}
col_pal <- RColorBrewer::brewer.pal(n = 8, name = "Dark2")
color_pal_sankey <- matrix(c("exposure", "red",
                             "lc",       "#b3d8ff",
                             "TC",      col_pal[2],
                             "CpG",       col_pal[1],
                             "miRNA",  col_pal[3],
                             "outcome",  "grey"), 
                           ncol = 2, byrow = TRUE) %>%
  as_tibble(.name_repair = "unique") %>% 
  janitor::clean_names() %>%
  dplyr::rename(group = x1, color = x2)

p3<- sankey_in_serial(fit1, 
                 fit2, 
                 fit3, 
                 color_pal_sankey,
                 text_size = 24)
```

![The Sankey Diagram for LUCID in Serial (Late Integration).](lucid_late.png){#fig-l_late}

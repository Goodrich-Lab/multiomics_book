[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Precision Health with Multi-Omics and Environmental Data: A Primer",
    "section": "",
    "text": "Preface\nIntegrating environmental data with biological data from multiple omics datasets can help provide unprecedented insights into the complex interplay of environment and biology. Joint analysis of environment and multi-omics can provide a more comprehensive picture of individual health and disease than individually analyzing datasets. However, to harness the full potential of using multi-omics data to understand environmental and biological drivers of disease, researchers need a robust framework for understanding how and why to perform different multiomic integration techniques.\nThis book is intended as a resource for researchers aiming to incorporate omics datasets to understand how environmental or biological factors impact human health and disease. We aim to explain the concepts, techniques, and methodologies that allow researchers to fully leverage the information in multidimensional datasets to obtain biologically relevant and actionable insights into environmental and biological impacts on disease.\nThis book has three sections corresponding to each column shown in Figure 1. In Chapter 2, we provide an example of high dimensional mediation with early, intermediate, and late integration, as shown in the first column of Figure 1. In Chapter 3, we provide an example of mediation with latent factors, a two-step approach that first uses dimensionality reduction on the omics datasets and then performs mediation on the resulting factors, as shown in the second column of Figure 1. In Chapter 4, we provide an example of quasi/intermediate integration, an approach where information on environmental factors and information on multiple omic layers are analyzed jointly in a single unified analysis, as shown in column 3 of Figure 1.\n\n\n\nFigure 1: Conceptual diagram illustrating the analytic framework for mediation analysis with multiple omic layers."
  },
  {
    "objectID": "intro.html#r-packages",
    "href": "intro.html#r-packages",
    "title": "1  Introduction",
    "section": "1.1 R Packages",
    "text": "1.1 R Packages\nThe following is a list of packages that are used throughout this book that need to be loaded before any analysis. A complete list of all the packages used in the book, as well as code to download these packages, can be found in Chapter 5.\n\n\nCode\n# General Packages:\nlibrary(EnvirOmix)\nlibrary(tidyverse)\nlibrary(table1)\n# Load plotting packages:\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(ComplexHeatmap)\nlibrary(ggh4x)\n# Packages for Quasi-mediation:\n#LUCIDus Version 3.0.1 is required for this analysis:\nlibrary(LUCIDus)\nlibrary(networkD3)\nlibrary(plotly)\nlibrary(htmlwidgets)\nlibrary(jsonlite)\n\n\nIn order to replicate the style of the figures in this book, you will also have to set the ggplot theme:\n\n\nCode\nggplot2::theme_set(cowplot::theme_cowplot())"
  },
  {
    "objectID": "intro.html#the-data",
    "href": "intro.html#the-data",
    "title": "1  Introduction",
    "section": "1.2 The Data",
    "text": "1.2 The Data\nThe data used in this project is based off of simulated data from the Human Early Life Exposome (HELIX) cohort (Vrijheid et al. 2014). The data was simulated for one exposure, five omics layers, and one continuous outcome (after publication, this data will be available on github). The format of this data is a named list with 6 elements. It includes separate numeric matrices for each of the 5 omics layers, as well as the exposure and phenotype data. In all datasets in the list, the rows represent individuals and the columns represent omics features. In this analysis, the exposure and outcome are:\n\n\nExposure: hs_hg_m_resid, representing maternal mercury levels\n\nOutcome: ck18_scaled, representing child liver enzyme levels, a major risk factor for non-alcoholic fatty liver disease (NAFLD).\n\nThis data is provided in the EnvirOmics package, which you can access in R using the following code:\n\n\nCode\n# Load R package\nlibrary(EnvirOmix)\n\n# Load simulated data\ndata(simulated_data)\n\n# Define exposure and outcome name\nexposure &lt;- simulated_data[[\"phenotype\"]]$hs_hg_m_scaled\noutcome  &lt;- simulated_data[[\"phenotype\"]]$ck18_scaled\n\n# Get numeric matrix of covariates \ncovs &lt;- simulated_data[[\"phenotype\"]][c(\"e3_sex_None\", \"hs_child_age_yrs_None\")] \ncovs$e3_sex_None &lt;- ifelse(covs$e3_sex_None == \"male\", 1, 0)\n\n# create list of omics data \nomics_lst &lt;- simulated_data[-which(names(simulated_data) == \"phenotype\")]\n\n# Create data frame of omics data\nomics_df &lt;- omics_lst |&gt; \n  purrr::map(~as_tibble(.x, rownames = \"name\")) |&gt;\n  purrr::reduce(left_join, by = \"name\") |&gt;\n  column_to_rownames(\"name\")\n\n\n\n1.2.1 Descriptive Statistics\nTable 1.1 shows the summary statistics for the exposure and phenotype data in this analysis.\n\n\nCode\ntable1::table1(~., data = simulated_data[[\"phenotype\"]][,-1])\n\n\n\n\n\n\nTable 1.1: Descriptive Statistics for the Simulated Variables\n\n\n\n\n\n\n\nOverall\n(N=420)\n\n\n\n\nhs_child_age_yrs_None\n\n\n\nMean (SD)\n7.22 (1.04)\n\n\nMedian [Min, Max]\n7.18 [3.93, 10.9]\n\n\nhs_hg_m_scaled\n\n\n\nMean (SD)\n-0.0148 (1.02)\n\n\nMedian [Min, Max]\n-0.0433 [-2.73, 3.34]\n\n\nck18_scaled\n\n\n\nMean (SD)\n-0.0511 (1.03)\n\n\nMedian [Min, Max]\n0.00883 [-3.56, 3.09]\n\n\ne3_sex_None\n\n\n\nfemale\n192 (45.7%)\n\n\nmale\n228 (54.3%)\n\n\nh_fish_preg_Ter\n\n\n\n1\n233 (55.5%)\n\n\n2\n88 (21.0%)\n\n\n3\n99 (23.6%)\n\n\n\n\n\n\n\n\n\n\n\n1.2.2 Mercury exposure and childhood MAFLD risk\n\n\nCode\nlm_res &lt;- lm(ck18_scaled ~ hs_hg_m_scaled + \n     e3_sex_None +\n     hs_child_age_yrs_None,\n   data = simulated_data[[\"phenotype\"]])\n\nsummary(lm_res)\n\n\nIn the simulated data, each 1 standard deviation increase in maternal mercury was associated with a 0.11 standard deviation increase in CK18 enzymes (Figure 1.1; p=0.02), after adjusting for child age and child sex.\n\n\nCode\nggplot(data = simulated_data[[\"phenotype\"]], \n       aes(x = hs_hg_m_scaled, y = ck18_scaled)) + \n  geom_point() +\n  stat_smooth(method = \"lm\",\n              formula = y ~ x ,\n              geom = \"smooth\") +\n  xlab(\"Maternal Mercury Exposure (Scaled)\") +\n  ylab(\"CK-18 Levels (Scaled)\")\n\n\n\n\n\nFigure 1.1: Association between maternal mercury and CK18 in the Simulated Data\n\n\n\n\n\n\n\n1.2.3 Correlation of omics features\nFigure 1.2 shows the correlation within and between the omics layers in the simulated data.\n\n\nCode\n# Change omics list elements to dataframes\nomics_df &lt;- purrr::map(omics_lst, ~as_tibble(.x, rownames = \"name\")) %&gt;%\n  purrr::reduce(left_join, by = \"name\") %&gt;%\n  column_to_rownames(\"name\")\n\nmeta_df &lt;- imap_dfr(purrr::map(omics_lst, ~as_tibble(.x)),\n                    ~tibble(omic_layer = .y, ftr_name = names(.x)))\n\n# Correlation Matrix\ncormat &lt;- cor(omics_df, method = \"pearson\")\n\n# Annotations\nannotation &lt;- data.frame(\n  ftr_name = colnames(cormat),\n  index = 1:ncol(cormat)) %&gt;%\n  left_join(meta_df, by = \"ftr_name\") %&gt;%\n  mutate(omic_layer = str_to_title(omic_layer))\n\n# Make Plot\nHeatmap(cormat, \n        row_split = annotation$omic_layer,\n        column_split = annotation$omic_layer,\n        show_row_names = FALSE,\n        show_column_names = FALSE, \n        column_title_gp = gpar(fontsize = 12),\n        row_title_gp = gpar(fontsize = 12),\n        heatmap_legend_param = list(title = \"Correlation\"))\n\n\n\n\n\nFigure 1.2: Heatmap illustrating the correlation of molecular features within and between different omics layers.\n\n\n\n\n\n\n\n\nVrijheid, Martine, Rémy Slama, Oliver Robinson, Leda Chatzi, Muireann Coen, Peter van den Hazel, Cathrine Thomsen, et al. 2014. “The Human Early-Life Exposome (HELIX): Project Rationale and Design.” Journal Article. Environmental Health Perspectives 122 (6): 535–44. https://doi.org/10.1289/ehp.1307204."
  },
  {
    "objectID": "HIMA.html#load-data-and-packages",
    "href": "HIMA.html#load-data-and-packages",
    "title": "2  High Dimensional Multiomic Mediation",
    "section": "2.1 Load data and packages",
    "text": "2.1 Load data and packages\nBefore starting, load the data and packages using the following code.\n\n\nCode\n# Load R package\nlibrary(EnvirOmix)\n\n# Load simulated data\ndata(simulated_data)\n\n# Define exposure and outcome name\nexposure &lt;- simulated_data[[\"phenotype\"]]$hs_hg_m_scaled\noutcome  &lt;- simulated_data[[\"phenotype\"]]$ck18_scaled\n\n# Get numeric matrix of covariates \ncovs &lt;- simulated_data[[\"phenotype\"]][c(\"e3_sex_None\", \"hs_child_age_yrs_None\")] \ncovs$e3_sex_None &lt;- ifelse(covs$e3_sex_None == \"male\", 1, 0)\n\n# create list of omics data \nomics_lst &lt;- simulated_data[-which(names(simulated_data) == \"phenotype\")]\n\n# Create data frame of omics data\nomics_df &lt;- omics_lst |&gt; \n  purrr::map(~as_tibble(.x, rownames = \"name\")) |&gt;\n  purrr::reduce(left_join, by = \"name\") |&gt;\n  column_to_rownames(\"name\")"
  },
  {
    "objectID": "HIMA.html#early-integration",
    "href": "HIMA.html#early-integration",
    "title": "2  High Dimensional Multiomic Mediation",
    "section": "2.2 Early integration",
    "text": "2.2 Early integration\nHigh dimensional multiomic mediation with early multiomic integration (Figure 1, panel a) identified differentially methylated CpG sites, gene transcript clusters, metabolites, and proteins which mediated associations of prenatal mercury with MAFLD risk in adolescents (Figure 2.1). Combining all omics layers before analysis identifies the strongest mediating feature across all omics layers without accounting for the differences in underlying correlation structure. For this analysis, we used High Dimensional Mediation Analysis (HIMA), a penalization-based mediation method implemented in the R package HIMA (Zhang et al. 2016).\n\n\nCode\n# Run Analysis\nresult_hima_early &lt;- hidimum(exposure = exposure,\n                             outcome = outcome, \n                             omics_lst = omics_lst, \n                             covs = covs,\n                             Y.family = \"gaussian\", \n                             M.family = \"gaussian\", \n                             integration = \"early\")\n# Plot Result\nplot_hidimum(result_hima_early)\n\n\n\n\n\nFigure 2.1: High dimensional mediation analysis with early integration and multiple omic layers identifies individual molecular features linking maternal mercury with childhood liver injury. Alpha represents the coefficient estimates of the exposure to the mediator, Beta indicates the coefficient estimates of the mediators to the outcome, and TME (%) represents the percent total effect mediated calculated as alpha*beta/gamma."
  },
  {
    "objectID": "HIMA.html#intermediate-integration",
    "href": "HIMA.html#intermediate-integration",
    "title": "2  High Dimensional Multiomic Mediation",
    "section": "2.3 Intermediate Integration",
    "text": "2.3 Intermediate Integration\nHigh dimensional mediation with intermediate multiomic integration (Figure 1, panel b) identified differentially methylated CpG sites, gene transcript clusters, and miRNA which mediated associations of prenatal mercury with MAFLD risk in adolescents (Figure 2.2). Combining all omics layers before analysis identifies the strongest mediating feature across all omics layers without accounting for the differences in underlying correlation structure.\nFor this analysis, we use a novel two-step approach that incorporates feature level metadata to inform on feature selection using xtune (Zeng, Thomas, and Lewinger 2021), an approach that allows for feature-specific penalty parameters and, in this example, performs a group-lasso-type shrinkage within each omic dataset. This analysis is similar in theory to HIMA, with the difference being that for this method the penalization can vary across each of the omic layers. This analysis was based on the product of coefficients method for mediation and was performed in three steps:\n\nRegression 1 (linear regression):\n\nFirst, we performed independent linear regression models for all exposure-mediator associations to get the exposure mediator coefficient:\n\\[\\begin{equation}\nm_i = a_0 + a_1 \\times x\n\\label{eq:reg1}\n\\end{equation}\\]\n   Where \\(x\\) is the exposure and \\(m_i\\) is each mediator.\n\nRegression 2 (group lasso):\n\nSecond, we performed a single group lasso regression for the mediator outcome associations, adjusting for the exposure, using the R package xtune (He and Zeng 2023). This step provided coefficients for each of the mediator outcome associations. We used bootstrapping to obtain the standard error of the coefficients from the group lasso regression for each of the mediator coefficients.\n\\[\\begin{equation}\ny = b_0 + b_1 \\times x + b_{2_i} \\times M\n\\label{eq:reg2}\n\\end{equation}\\]\n   Where \\(y\\) is the outcome, \\(x\\) is the exposure, \\(M\\) is the mediator matrix with corresponding estimate \\(b_{2_i}\\). The bootstrapped standard error (se) of \\(b_{2_i}\\) is used for calculating mediation confidence intervals.\n\nCalculate mediation confidence interval for mediator ( i ):\n\nFinally, for each omic feature, we calculated the mediation effect and 95% confidence intervals using the R package RMediation, which is based on the distribution-of-the-product method (Tofighi and MacKinnon 2011).\n\\[\\begin{align}\n\\alpha &= a_1 \\label{eq:alpha}\\\\\n\\text{se of } \\alpha &= \\text{se of } a_1 \\label{eq:se_alpha}\\\\\n\\beta &= b_{2_i} \\label{eq:beta}\\\\\n\\text{se of } \\beta &= \\text{se of } b_{2_i} \\label{eq:se_beta}\n\\end{align}\\]\nNote: For the actual analysis, we would normally set n_boot to a higher value (1000 or more). In the example code, it is set to 12 to improve the speed of the function.\n\n\nCode\n# Run Analysis\nresult_hima_intermediate &lt;- hidimum(omics_lst = omics_lst,\n                                    covs = covs,\n                                    outcome = outcome,\n                                    exposure = exposure,\n                                    n_boot = 12,\n                                    Y.family = \"gaussian\", \n                                    integration = \"intermediate\")\n\n\n\n\nCode\n# plot\nplot_hidimum(result_hima_intermediate)\n\n\n\n\n\nFigure 2.2: High dimensional mediation analysis with intermediate integration and multiple omic layers identifies individual molecular features linking maternal mercury with childhood liver injury. Alpha represents the coefficient estimates of the exposure to the mediator, Beta indicates the coefficient estimates of the mediators to the outcome, and TME (%) represents the percent total effect mediated calculated as alpha*beta/gamma."
  },
  {
    "objectID": "HIMA.html#late-integration",
    "href": "HIMA.html#late-integration",
    "title": "2  High Dimensional Multiomic Mediation",
    "section": "2.4 Late integration",
    "text": "2.4 Late integration\nHigh dimensional mediation with late multiomic integration (Figure 1, panel c) identified differentially methylated CpG sites, gene transcript clusters, and miRNA which mediated associations of prenatal mercury with MAFLD risk in adolescents (Figure 2.3). High dimensional mediation with late multiomic integration differs from the early and intermediate integration in that each omics layer is analyzed individually. Thus, this approach does not condition on features within the other omics layers in the analysis.\nCombining all omics layers before analysis identifies the strongest mediating feature across all omics layers without accounting for the differences in underlying correlation structure. For this analysis, we used High Dimensional Mediation Analysis (HIMA), a penalization-based mediation method implemented in the R package HIMA (Zhang et al. 2016).\n\n\nCode\n# Run Analysis\nresult_hima_late &lt;- hidimum(exposure = exposure,\n                            outcome = outcome, \n                            omics_lst = omics_lst, \n                            covs = covs, \n                            Y.family = \"gaussian\", \n                            M.family = \"gaussian\", \n                            integration = \"late\")\n\n# plot\nplot_hidimum(result_hima_late)\n\n\n\n\n\nFigure 2.3: High dimensional mediation analysis with late integration and multiple omic layers identifies individual molecular features linking maternal mercury with childhood liver injury. Alpha represents the coefficient estimates of the exposure to the mediator, Beta indicates the coefficient estimates of the mediators to the outcome, and TME (%) represents the percent total effect mediated calculated as alpha*beta/gamma.\n\n\n\n\n\n\n\n\nHe, Jingxuan, and Chubing Zeng. 2023. “Xtune: Regularized Regression with Feature-Specific Penalties Integrating External Information.” Computer Program. https://github.com/JingxuanH/xtune.\n\n\nTofighi, D., and D. P. MacKinnon. 2011. “RMediation: An r Package for Mediation Analysis Confidence Intervals.” Journal Article. Behav Res Methods 43 (3): 692–700. https://doi.org/10.3758/s13428-011-0076-x.\n\n\nZeng, C., D. C. Thomas, and J. P. Lewinger. 2021. “Incorporating Prior Knowledge into Regularized Regression.” Journal Article. Bioinformatics 37 (4): 514–21. https://doi.org/10.1093/bioinformatics/btaa776.\n\n\nZhang, H., Y. Zheng, Z. Zhang, T. Gao, B. Joyce, G. Yoon, W. Zhang, et al. 2016. “Estimating and Testing High-Dimensional Mediation Effects in Epigenetic Studies.” Journal Article. Bioinformatics 32 (20): 3150–54. https://doi.org/10.1093/bioinformatics/btw351."
  },
  {
    "objectID": "Mediation_with_latent_fctrs.html#load-data-and-packages-for-mediation-analysis-with-latent-factors",
    "href": "Mediation_with_latent_fctrs.html#load-data-and-packages-for-mediation-analysis-with-latent-factors",
    "title": "3  Mediation with latent factors",
    "section": "3.1 Load data and packages for Mediation Analysis with Latent factors",
    "text": "3.1 Load data and packages for Mediation Analysis with Latent factors\nBefore starting, load the data and packages using the following code.\n\n\nCode\n# Load R package\nlibrary(EnvirOmix)\n\n# Load simulated data\ndata(simulated_data)\n\n# Define exposure and outcome name\nexposure &lt;- simulated_data[[\"phenotype\"]]$hs_hg_m_scaled\noutcome  &lt;- simulated_data[[\"phenotype\"]]$ck18_scaled\n\n# Get numeric matrix of covariates \ncovs &lt;- simulated_data[[\"phenotype\"]][c(\"e3_sex_None\", \"hs_child_age_yrs_None\")] \ncovs$e3_sex_None &lt;- ifelse(covs$e3_sex_None == \"male\", 1, 0)\n\n# create list of omics data \nomics_lst &lt;- simulated_data[-which(names(simulated_data) == \"phenotype\")]\n\n# Create data frame of omics data\nomics_df &lt;- omics_lst |&gt; \n  purrr::map(~as_tibble(.x, rownames = \"name\")) |&gt;\n  purrr::reduce(left_join, by = \"name\") |&gt;\n  column_to_rownames(\"name\")"
  },
  {
    "objectID": "Mediation_with_latent_fctrs.html#early-integration",
    "href": "Mediation_with_latent_fctrs.html#early-integration",
    "title": "3  Mediation with latent factors",
    "section": "3.2 Early integration",
    "text": "3.2 Early integration\nFor early integration, we used principal component analysis (PCA) as a dimensionality reduction step and selected the top i principal components which explained &gt;80% of the variance. Following the joint dimensionality reduction step, we used the r package HIMA (Zhang et al. 2016) to examine whether the variance components mediated associations of in utero mercury exposure with MAFLD.\nIn this analysis, principal components explained &gt;80% of the variance in the combined omics datasets. Of these components, 7 significantly mediated the relationship between maternal mercury and childhood liver injury (Figure 3.1).\n\n3.2.1 HIMA Early Integration\n\n\nCode\n# Run Analysis\nresult_med_with_latent_fctrs_early &lt;-\n  lafamum(exposure, \n          outcome,\n          omics_lst, \n          covs = covs,\n          Y.family = \"gaussian\",\n          fdr.level = 0.05, \n          integration = \"early\")\n\n\n\n\n3.2.2 Plot Early Integration\n\n\nCode\n# Plot\n(plot_lafamum(result_med_with_latent_fctrs_early))\n\n\n\n\n\nFigure 3.1: Mediation analysis with latent factors and early integration identifies joing components which mediate the association between maternal mercury and childhood liver injury. Panel A shows the mediation effects, where Alpha represents the coefficient estimates of the exposure to the mediator, Beta indicates the coefficient estimates of the mediators to the outcome, and TME (%) represents the percent total effect mediated calculated as alpha*beta/gamma. Panel B shows the individual correlation between the omic feature and the joint component."
  },
  {
    "objectID": "Mediation_with_latent_fctrs.html#intermediate-integration",
    "href": "Mediation_with_latent_fctrs.html#intermediate-integration",
    "title": "3  Mediation with latent factors",
    "section": "3.3 Intermediate Integration",
    "text": "3.3 Intermediate Integration\nThe steps for intermediate integration start with performing a joint dimensionality reduction step using Joint and Individual Variance Explained (JIVE) (Lock et al. 2013). Following the joint dimensionality reduction step, we used the r package HIMA (Zhang et al. 2016) to examine whether the variance components mediated associations of in utero mercury exposure with MAFLD.\n\n3.3.1 Conduct JIVE and Perform Mediation Analysis\n\n3.3.1.1 Conduct JIVE\nFor this step, JIVE can estimate the optimal number of joint and individual ranks by changing the method argument in the function jive. For the simulated HELIX data, the optimal number, determined by setting method = \"perm\", was 22 joint ranks and 6, 9, 5, 5, and 8 ranks for the methylome, transcriptome, miRNA, proteome, and metabolome, respectively.\n\n\n3.3.1.2 Perform mediation analysis\nIn this analysis, 6 joint components, 1 transcriptome specific component significantly mediated the relationship between maternal mercury and childhood liver injury (Figure 3.2).\n\n\nCode\n# Run analysis with rnkJ and rankA provided\nresult_med_with_latent_fctrs_JIVE &lt;- \n  lafamum(exposure, outcome,\n          jive.rankJ = 22,\n          jive.rankA = c(6, 9, 5, 5, 8),\n          omics_lst,\n          covs = covs, \n          Y.family = \"gaussian\",\n          fdr.level = 0.05, \n          integration = \"intermediate\")\n\n\n\n\n\n3.3.2 Plot Intermediate Integration\n\n\nCode\n(plot_lafamum(result_med_with_latent_fctrs_JIVE))\n\n\n\n\n\nFigure 3.2: Mediation analysis with latent factors and intermediate integration identifies joint and individual variance componets which mediate the association between maternal mercury and childhood liver injury. Panel A shows the mediation effects, where Alpha represents the coefficient estimates of the exposure to the mediator, Beta indicates the coefficient estimates of the mediators to the outcome, and TME (%) represents the percent total effect mediated calculated as alpha*beta/gamma. Panel B shows the individual correlation between the omic feature and the joint and individual components."
  },
  {
    "objectID": "Mediation_with_latent_fctrs.html#late-integration",
    "href": "Mediation_with_latent_fctrs.html#late-integration",
    "title": "3  Mediation with latent factors",
    "section": "3.4 Late integration",
    "text": "3.4 Late integration\nFor late integration, we used principal component analysis (PCA) as a dimensionality reduction step on each omics layer separately, and selected the top i principal components which explained &gt;80% of the variance. Following the dimensionality reduction step, we used the r package HIMA (Zhang et al. 2016) to examine whether the variance components mediated associations of in utero mercury exposure with MAFLD.\nThis analysis identified 2 methylated CpG sites, 1 miRNA, 1 protein and 2 expressed gene transcript clutesrs significantly mediated the association between mercury and MAFLD (Figure 3.3).\n\n3.4.1 HIMA Late Integration\n\n\nCode\nresult_med_with_latent_fctrs_late &lt;- lafamum(exposure, \n                                             outcome,\n                                             omics_lst, \n                                             covs = covs,\n                                             Y.family = \"gaussian\",\n                                             fdr.level = 0.05, \n                                             integration = \"late\")\n\n\n\n\n3.4.2 Plot Late Integration\n\n\nCode\n(plot_lafamum(result_med_with_latent_fctrs_late))\n\n\n\n\n\nFigure 3.3: Mediation analysis with latent factors and late integration identifies features in each omics layer individually which mediates the association between maternal mercury and childhood liver injury. Panel A shows the mediation effects, where Alpha represents the coefficient estimates of the exposure to the mediator, Beta indicates the coefficient estimates of the mediators to the outcome, and TME (%) represents the percent total effect mediated calculated as alpha*beta/gamma. Panel B shows the individual correlation between the omic feature and components."
  },
  {
    "objectID": "Mediation_with_latent_fctrs.html#pathway-analysis.",
    "href": "Mediation_with_latent_fctrs.html#pathway-analysis.",
    "title": "3  Mediation with latent factors",
    "section": "3.5 Pathway Analysis.",
    "text": "3.5 Pathway Analysis.\nFollowing mediation analysis, you can use the correlation p-values to perform pathway analysis with appropriate pathway analysis software.\n\n\n\n\nLock, E. F., K. A. Hoadley, J. S. Marron, and A. B. Nobel. 2013. “JOINT AND INDIVIDUAL VARIATION EXPLAINED (JIVE) FOR INTEGRATED ANALYSIS OF MULTIPLE DATA TYPES.” Journal Article. Ann Appl Stat 7 (1): 523–42. https://doi.org/10.1214/12-aoas597.\n\n\nZhang, H., Y. Zheng, Z. Zhang, T. Gao, B. Joyce, G. Yoon, W. Zhang, et al. 2016. “Estimating and Testing High-Dimensional Mediation Effects in Epigenetic Studies.” Journal Article. Bioinformatics 32 (20): 3150–54. https://doi.org/10.1093/bioinformatics/btw351."
  },
  {
    "objectID": "Quasi_mediation.html#load-data-and-packages",
    "href": "Quasi_mediation.html#load-data-and-packages",
    "title": "4  Integrated/Quasi-Mediation",
    "section": "4.1 Load data and packages",
    "text": "4.1 Load data and packages\nBefore starting, load required packages. The code in this section relies heavily on the functions from the R package LUCIDus (Peng et al. 2020).\n\n\nCode\n# General Packages:\nlibrary(EnvirOmix)\nlibrary(tidyverse)\nlibrary(table1)\n# Load plotting packages:\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(ComplexHeatmap)\nlibrary(ggh4x)\n# Packages for Quasi-mediation:\n#LUCIDus Version 3.0.1 is required for this analysis:\nlibrary(LUCIDus)\nlibrary(networkD3)\nlibrary(plotly)\nlibrary(htmlwidgets)\nlibrary(jsonlite)\n\n\nAnd load the data:\n\n\nCode\n# Load R package\nlibrary(EnvirOmix)\n\n# Load simulated data\ndata(simulated_data)\n\n# Define exposure and outcome name\nexposure &lt;- simulated_data[[\"phenotype\"]]$hs_hg_m_scaled\noutcome  &lt;- simulated_data[[\"phenotype\"]]$ck18_scaled\n\n# Get numeric matrix of covariates \ncovs &lt;- simulated_data[[\"phenotype\"]][c(\"e3_sex_None\", \"hs_child_age_yrs_None\")] \ncovs$e3_sex_None &lt;- ifelse(covs$e3_sex_None == \"male\", 1, 0)\n\n# create list of omics data \nomics_lst &lt;- simulated_data[-which(names(simulated_data) == \"phenotype\")]\n\n# Create data frame of omics data\nomics_df &lt;- omics_lst |&gt; \n  purrr::map(~as_tibble(.x, rownames = \"name\")) |&gt;\n  purrr::reduce(left_join, by = \"name\") |&gt;\n  column_to_rownames(\"name\")\n\n\nFor this analysis, we will subset to only three omics layers to reduce the computational burden.\n\n\nCode\n# Three omics layers, Methylation (CpG), Transcriptome and miRNA\nomics_df_analysis &lt;- omics_df %&gt;% \n  dplyr::select(contains(\"cg\"), contains(\"TC\"), contains(\"miR\"))\n\n\nThe figures for quasi-mediation rely on several custom functions. The code for functions are provided in Chapter 6."
  },
  {
    "objectID": "Quasi_mediation.html#early-integration",
    "href": "Quasi_mediation.html#early-integration",
    "title": "4  Integrated/Quasi-Mediation",
    "section": "4.2 Early Integration",
    "text": "4.2 Early Integration\nIn the Early Integration model, genomic/exposomic exposures \\(G\\), other omics data \\(Z\\) and phenotype trait \\(Y\\) are integrated through a latent categorical variable \\(X\\), as implemented in the R package LUCIDus (Peng et al. 2020). Because \\(X\\) is an unobserved categorical variable, each category of \\(X\\) is interpreted as a latent cluster in the data, jointly defined by \\(G\\), \\(Z\\) and \\(Y\\). Let \\(G\\) be a \\(N \\times P\\) matrix with columns representing genetic/environmental exposures, and rows representing the observations; \\(Z\\) be a \\(N \\times M\\) matrix of omics data (for example, gene expression data, DNA methylation profiles and metabolomic data etc.) and \\(Y\\) be a \\(N\\)-length vector of phenotype trait. We further assume \\(G\\), \\(Z\\) and \\(Y\\) are measured through a prospective sampling procedure so we do not model the distribution of \\(G\\). All three measured components (\\(G\\), \\(Z\\) and \\(Y\\)) are linked by a latent variable \\(X\\) consisting of \\(K\\) categories. The distributions of \\(X\\) given \\(G\\), \\(Z\\) given \\(X\\) and \\(Y\\) given \\(X\\) are conditionally independent with each other. Let \\(f(\\cdot)\\) denote the probability mass functions (PMF) for categorical random variables or the probability density functions (PDF) for continuous random variables. The joint log-likelihood of the LUCID model is constructed as:\n\\[\n\\begin{aligned}\n\\log L({\\Theta}) & = \\sum_{i = 1}^N \\log f({Z}_i, Y_i|{G}_i;{\\Theta}) \\\\\n& = \\sum_{i = 1}^N \\log \\sum_{j = 1}^K f(X_i = j|{G}_i;{\\Theta}) f({Z}_i| X_i = j; {\\Theta}) f(Y_i|X_i = j; {\\Theta})\n\\end{aligned}\n\\] where \\(\\Theta\\) is a generic notation for all parameters in Early Integration LUCID model. EM algorithm is implemented to estimate all parameters \\(\\Theta\\) iteratively until convergence, and \\(\\Theta\\) represents the \\(G\\) to \\(X\\), \\(X\\) to \\(Z\\), and \\(X\\) to \\(Y\\) associations,\nWe a-priori assigned the number of clusters to two. Early Integration LUCID estimates two omics specific clusters which represent an differential risks for the outcome. These omic profiles confer different risks of the outcome and represent each omics feature’s contribution to the exposure-outcome association.\n\n4.2.1 Analysis: Early Integration\nWhen using estimate_lucid() to fit the Early Integration LUCID model, we specify lucid_model = \"early\", and K is an integer representing number of latent clusters. G, Z, Y are the inputs for exposure, omics data matrix, and the outcome, respectively.CoY are the covariates to be adjusted for the \\(X\\) to \\(Y\\) association and CoG are the covariates to be adjusted for the \\(G\\) to \\(X\\) association. We specify useY = TRUE to construct supervised LUCID model. Otherwise, useY = FALSE will construct unsupervised LUCID model. init_par = \"random\" means that we initiate the parameters with random guess. We specify family = \"normal\" since the outcome is continuous. If the outcome is binary, we would specify family = \"binary\".The full code for the sankey_early_integration function is provided in Section 6.1.1\n\n\nCode\nG = exposure |&gt; as.matrix()\nZ = omics_df_analysis |&gt; as.matrix()\n\nfit1 &lt;- estimate_lucid(lucid_model = \"early\",\n                       G = G,\n                       Z = Z,\n                       Y = outcome, \n                       K = 2,\n                       CoY = covs,\n                       CoG = covs,\n                       useY = TRUE,\n                       init_par = \"random\",\n                       family = \"normal\")\n## .....\n\n\n\n\n4.2.2 Sankey Diagram\n\n\nCode\np1 &lt;- sankey_early_integration(fit1, text_size = 20)\n\n\n\n\n\nFigure 4.1: The Sankey Diagram for LUCID (Early Integration).\n\n\n\n\n4.2.3 Early Integration Results\nOmics profiles for each cluster determined using Early Integration LUCID. The full code for the plot_omics_profiles function is provided in Section 6.1.4\n\n\nCode\nplot_omics_profiles(fit1, \"Early\", omics_lst)"
  },
  {
    "objectID": "Quasi_mediation.html#intermediate-integration",
    "href": "Quasi_mediation.html#intermediate-integration",
    "title": "4  Integrated/Quasi-Mediation",
    "section": "4.3 Intermediate Integration",
    "text": "4.3 Intermediate Integration\nIn LUCID in parallel conducting intermediate integration, latent clusters \\(X_a\\) are estimated in each omics layer separately while integrating information from the genetic/environmental exposure \\(G\\) and the outcome \\(Y\\) by assuming no correlations across different omics layers. Let \\(G\\) be a \\(N \\times P\\) matrix with columns representing genetic/environmental exposures, and rows representing the observations; there is a collection of \\(m\\) omics data, denoted by \\(Z_1\\), . . . , \\(Z_a\\), . . . , \\(Z_m\\) with corresponding dimensions \\(p_1\\), . . . , \\(p_a\\), . . . , \\(p_m\\). Each omics data \\(Z_a\\) is summarized by a latent categorical variable \\(X_a\\), which contains \\(K_a\\) categories. Each category is interpreted as a latent cluster (or subgroup) for that particular omics layer and \\(Y\\) be a \\(N\\)-length vector of phenotype trait. Let \\(D\\) be the generic notation for all observed data. The log likelihood of LUCID with multiple latent variables is constructed below,\n\\[\n\\begin{aligned}\nl(\\boldsymbol{\\Theta} \\mid \\boldsymbol{D}) & =\\sum_{i=1}^{n} \\log f\\left(\\boldsymbol{Z}_{1 i}, \\ldots, \\boldsymbol{Z}_{m i}, \\boldsymbol{Y}_{i} \\mid \\boldsymbol{G}_{i} ; \\boldsymbol{\\Theta}\\right) \\\\\n& =\\sum_{i=1}^{n} \\log \\left[\\prod_{j_{1}=1}^{k_{1}} \\cdots \\prod_{j_{m}=1}^{k_{m}} f\\left(\\boldsymbol{Z}_{1 i}, \\ldots, \\boldsymbol{Z}_{m i}, X_{1 i}, \\ldots, X_{m i}, Y_{i} \\mid \\boldsymbol{G}_{i} ; \\boldsymbol{\\Theta}\\right)^{I\\left(X_{1 i}=j_{1}, \\ldots, X_{m i}=j_{m}\\right)}\\right] \\\\\n& =\\sum_{i=1}^{n} \\sum_{j_{1}=1}^{k_{1}} \\ldots \\sum_{j_{m}=1}^{k_{m}} I\\left(X_{1 i}=j_{1}, \\ldots, X_{m i}=j_{m}\\right) \\log f\\left(\\boldsymbol{Z}_{1 i}, \\ldots, \\boldsymbol{Z}_{m i}, X_{1 i}, \\ldots, X_{m i}, Y_{i} \\mid \\boldsymbol{G}_{i} ; \\boldsymbol{\\Theta}\\right) \\\\\n& =\\sum_{i=1}^{n} \\sum_{j_{1}=1}^{k_{1}} \\ldots \\sum_{j_{m}=1}^{k_{m}} I\\left(X_{1 i}=j_{1}, \\ldots, X_{m i}=j_{m}\\right) \\log \\phi\\left(Y_{i} \\mid X_{1 i}, \\ldots, X_{m i}, \\boldsymbol{\\delta}, \\sigma^{2}\\right) \\\\\n& +\\sum_{i=1}^{n} \\sum_{a=1}^{m} \\sum_{j_{1}=1}^{k_{1}} \\ldots \\sum_{j_{m}=1}^{k_{m}} I\\left(X_{1 i}=j_{1}, \\ldots, X_{m i}=j_{m}\\right) \\log \\phi\\left(\\boldsymbol{Z}_{a i} \\mid X_{a i}=j_{a}, \\boldsymbol{\\mu}_{a, j_{a}}, \\boldsymbol{\\Sigma}_{a, j_{a}}\\right) \\\\\n& +\\sum_{i=1}^{n} \\sum_{a=1}^{m} \\sum_{j_{1}=1}^{k_{1}} \\ldots \\sum_{j_{m}=1}^{k_{m}} I\\left(X_{1 i}=j_{1}, \\ldots, X_{m i}=j_{m}\\right) \\log S\\left(\\boldsymbol{X}_{a i}=j_{a} \\mid \\boldsymbol{G}_{i}, \\boldsymbol{\\beta}_{a}\\right)\n\\end{aligned}\n\\]\nThe log likelihood of LUCID in parallel is similar to that with Early integration LUCID. It is natural to follow the same principles of EM algorithm for Early integration LUCID with single intermediate variable.\nWe a-priori assigned the number of clusters for each omic layer to two. LUCID in parallel estimates omics specific clusters which represent an differential risks for the outcome within the layer. For each set of latent clusters within each omics layer, the corresponding omics profile was computed to identify the independent contribution of each omics layer to the exposure-outcome association.\n\n4.3.1 Analysis: LUCID with 3 omics layers in parallel\nWhen using estimate_lucid() to fit LUCID in parallel model, we specify lucid_model = \"parallel\", and K is a list with the same length as the number of omics layers and each element in the list is an integer representing number of latent clusters for the corresponding omics layer. max_itr = 200 means that the algorithm will stop when the iterations reaches 200 if still not reaching convergence. We specify useY = TRUE to construct supervised LUCID model. modelName is a vector of strings specifies the geometric model of omics data, the default modelName is “VVV”, but here “EEV” is more suitable.\n\n\nCode\nG = exposure %&gt;% as.matrix()\nZ = omics_lst[c(1:3)]\nY = outcome \n\nfit &lt;- estimate_lucid(lucid_model = \"parallel\",\n                      G = G, \n                      Z = Z, \n                      Y = Y,\n                      K = rep(2, length(Z)), \n                      family = \"normal\", \n                      max_itr = 200, \n                      useY = TRUE, \n                      init_omic.data.model  = \"EEV\")\n\n# Reorder the clusters\nfit_reordered &lt;- reorder_lucid_parallel(fit, reference = c(2,2,2))\n\n\n\n\n4.3.2 Sankey Diagram\nThe full code for the plot_lucid_in_parellel_plotly function is provided in Section 6.1.2\n\n\nCode\np2 &lt;- plot_lucid_in_parallel_plotly(fit_reordered,\n                                    sankey_colors = sankey_colors,\n                                    text_size = 20,\n                                    n_z_ftrs_to_plot = c(7,7,7))\n\n\n\n\n\nFigure 4.2: The Sankey Diagram for LUCID in Parallel (Intermediate Integration).\n\n\n\n\n4.3.3 Omics profiles for each cluster predicted by LUCID\nThe full code for the plot_omics_profiles function is provided in Section 6.1.4\n\n\nCode\nplot_omics_profiles(fit_reordered, \"Intermediate\", omics_lst)"
  },
  {
    "objectID": "Quasi_mediation.html#late-integration",
    "href": "Quasi_mediation.html#late-integration",
    "title": "4  Integrated/Quasi-Mediation",
    "section": "4.4 Late Integration",
    "text": "4.4 Late Integration\nFor late integration, LUCID in serial is implemented, which successively links multiple single omics LUCID models using the Early Integration LUCID model. Let \\(G\\) be a \\(N \\times P\\) matrix with columns representing genetic/environmental exposures, and rows representing the observations; there is an ordered collection of \\(m\\) omics data, denoted by \\(Z_1\\), . . . , \\(Z_a\\), . . . , \\(Z_m\\) with corresponding dimensions \\(p_1\\), . . . , \\(p_a\\), . . . , \\(p_m\\). Successive omics layers \\(Z_a\\) are linked by using each observations’ posterior inclusion probability (PIP) for latent clusters \\(X_a\\) in the initial LUCID model to be the “exposure” variable for each successive model. The omics layers are ordered in a sequential fashion based on the biological relationships between omics layers. For the first model, an unsupervised Early Integration LUCID model using \\(G\\) as the exposure and \\(Z_1\\) as the omics layer. The PIPs of the non-reference clusters were extracted and used as the input for the exposure for the following unsupervised Early Integration LUCID model. This procedure is iterated until the last omics layer \\(Z_m\\), for which a supervised Early Integration LUCID model is used to conduct integrated clustering while using PIPs from the previous LUCID model and information on the outcome \\(Y\\).\n\n4.4.1 Analysis: LUCID with 3 omics layers in serial\nWhen using estimate_lucid() to fit LUCID in serial model, we specify lucid_model = \"serial\", and K is a list with the same length as the number of ordered omics layers and each element in the list is an integer representing number of latent clusters for the corresponding omics layer. G, Z, Y are the inputs for exposure, omics data matrix, and the outcome, respectively. Note that here Z is list of omics layers (vectors). CoY are the covariates to be adjusted for the \\(X\\) to \\(Y\\) association and CoG are the covariates to be adjusted for the \\(G\\) to \\(X\\) association. We specify useY = TRUE to construct supervised LUCID in serial model. We specify family = \"normal\" since the outcome is continuous. If the outcome is binary, we would specify family = \"binary\". We specify Rho_Z_Mu = 10 and Rho_Z_Cov = .3 to use LASSO penalty to regularize cluster-specific means and variance for \\(Z\\). We will get a selection of \\(Z\\) features for each layer, and then we refit the LUCID in serial model with only selected \\(Z\\) features to construct the final model.\n\n\nCode\nset.seed(100)\nG_Hg = exposure %&gt;% as.matrix()\nZ = list(omics_lst$methylome,\n         omics_lst$transcriptome,\n         omics_lst$miRNA)\nY_liv_inj = scale(outcome)\n\n# Run the LUCID Model  \nfit &lt;- estimate_lucid(lucid_model = \"serial\",\n                      G = G_Hg,\n                      Z = Z,\n                      Y = Y_liv_inj, \n                      CoY = covs,\n                      CoG = covs,\n                      K = list(2,2,2),\n                      useY = TRUE,\n                      family = \"normal\", \n                      Rho_Z_Mu = 10,\n                      Rho_Z_Cov = .3)\n\n#extract selected Z features to to refit lUCID in serial\nselected_Z = vector(mode = \"list\", length = length(Z))\nfor (i in (1:length(Z))){\n  fiti_select_Z = fit$submodel[[i]]$select$selectZ\n  selected_Z[[i]] = Z[[i]][,fiti_select_Z]\n}\n\n#Refit ther LUCID in serial model with selected Z\nfit &lt;- estimate_lucid(lucid_model = \"serial\",\n                      G = G_Hg,\n                      Z = selected_Z,\n                      Y = Y_liv_inj, \n                      CoY = covs,\n                      CoG = covs,\n                      K = list(2,2,2),\n                      useY = TRUE,\n                      init_par = \"random\",\n                      family = \"normal\")\n\n# Rename Exposure\nfit1 &lt;- fit$submodel[[1]]\nfit1$var.names$Gnames[1] &lt;- \"Hg\"\nfit2 &lt;- fit$submodel[[2]]\nfit2$var.names$Gnames[1] &lt;- \"&lt;b&gt;Methylation\\nProfile 1&lt;/b&gt;\"\nfit3 &lt;- fit$submodel[[3]]\nfit3$var.names$Gnames[1] &lt;- \"&lt;b&gt;miRNA\\nProfile 1&lt;/b&gt;\"\n\n\n\n\n4.4.2 Sankey Diagram\nThe full code for the sankey_in_serial function is provided in Section 6.1.3.\n\n\nCode\ncol_pal &lt;- RColorBrewer::brewer.pal(n = 8, name = \"Dark2\")\ncolor_pal_sankey &lt;- matrix(c(\"exposure\", \"red\",\n                             \"lc\"      , \"#b3d8ff\",\n                             \"TC\"      , col_pal[2],\n                             \"CpG\"     , col_pal[1],\n                             \"miRNA\"   , col_pal[3],\n                             \"outcome\" , \"grey\"), \n                           ncol = 2, byrow = TRUE) %&gt;%\n  as_tibble(.name_repair = \"unique\") %&gt;% \n  janitor::clean_names() %&gt;%\n  dplyr::rename(group = x1, color = x2)\n\np3&lt;- sankey_in_serial(fit1, \n                      fit2, \n                      fit3, \n                      color_pal_sankey,\n                      text_size = 24)\n\n\n\n\n\nFigure 4.3: The Sankey Diagram for LUCID in Serial (Late Integration).\n\n\n\n\n\n\nPeng, C., J. Wang, I. Asante, S. Louie, R. Jin, L. Chatzi, G. Casey, D. C. Thomas, and D. V. Conti. 2020. “A Latent Unknown Clustering Integrating Multi-Omics Data (LUCID) with Phenotypic Traits.” Journal Article. Bioinformatics 36 (3): 842–50. https://doi.org/10.1093/bioinformatics/btz667."
  },
  {
    "objectID": "software.html#installing-r-packages",
    "href": "software.html#installing-r-packages",
    "title": "5  Software",
    "section": "5.1 Installing R packages",
    "text": "5.1 Installing R packages\nThe following code will download all the packages needed to run the analyses in this book.\n\n\nCode\n# Download EnvirOmix package if not already installed:\nif(!requireNamespace(\"EnvirOmix\", quietly = TRUE)){\n  if(!requireNamespace(\"devtools\", quietly = TRUE)) install.packages(\"devtools\")\n  devtools::install_github(\"Goodrich-Lab/EnvirOmix\")\n}\n\n# List all CRAN packages used in this book:\ncran_packages &lt;- c(\"tidyverse\",\n                   \"tools\",\n                   \"parallel\",\n                   \"boot\",\n                   \"table1\",\n                   \"BiocManager\",\n                   \"ggplot2\",\n                   \"cowplot\",\n                   \"ggh4x\",\n                   \"LUCIDus\",\n                   \"networkD3\",\n                   \"plotly\",\n                   \"htmlwidgets\",\n                   \"jsonlite\")\n\n# Install cran packages if not already installed:\nfor(package_name in cran_packages){\n  if(!requireNamespace(package_name, quietly = TRUE)){\n    install.packages(package_name, repos = \"http://cran.r-project.org/\")\n  }\n}\n\n# List all Bioconductor packages used in this book:\nbioconductor_packages &lt;- c(\"BiocGenerics\", \n                           \"ComplexHeatmap\", \n                           \"IRanges\",\n                           \"S4Vectors\")\n\n# Install bioconductor packages if not already installed:\nfor(package_name in bioconductor_packages){\n  if(!requireNamespace(package_name, quietly = TRUE)){\n    BiocManager::install(package_name)\n  }\n}"
  },
  {
    "objectID": "software.html#r-development-environment",
    "href": "software.html#r-development-environment",
    "title": "5  Software",
    "section": "5.2 R development environment",
    "text": "5.2 R development environment\nThe following table lists the package versions and corresponding repository of all the R packages that were used to develop the code in this book.\n\n\n\n\n\nList of all R Packages used in this book.\n\n\nPackage\nVersion\nAttached or Loaded\nDate/Publication\nSource\n\n\n\n\nComplexHeatmap\n2.16.0\nAttached\n2023-05-08\nBioconductor\n\n\ncowplot\n1.1.1\nAttached\n2020-12-30\nCRAN (R 4.3.0)\n\n\ndevtools\n2.4.5\nAttached\n2022-10-11\nCRAN (R 4.3.0)\n\n\ndplyr\n1.1.3\nAttached\n2023-09-03\nCRAN (R 4.3.0)\n\n\nEnvirOmix\n0.0.0.9000\nAttached\n2023-11-03\nBioconductor\n\n\nforcats\n1.0.0\nAttached\n2023-01-29\nCRAN (R 4.3.0)\n\n\nggh4x\n0.2.6\nAttached\n2023-08-30\nCRAN (R 4.3.0)\n\n\nggplot2\n3.4.4\nAttached\n2023-10-12\nCRAN (R 4.3.1)\n\n\nhtmlwidgets\n1.6.2\nAttached\n2023-03-17\nCRAN (R 4.3.0)\n\n\njsonlite\n1.8.7\nAttached\n2023-06-29\nCRAN (R 4.3.0)\n\n\nlubridate\n1.9.3\nAttached\n2023-09-27\nCRAN (R 4.3.1)\n\n\nLUCIDus\n3.0.1\nAttached\n2023-10-31\nCRAN (R 4.3.1)\n\n\nnetworkD3\n0.4\nAttached\n2017-03-18\nCRAN (R 4.3.0)\n\n\nplotly\n4.10.2\nAttached\n2023-06-03\nCRAN (R 4.3.0)\n\n\npurrr\n1.0.2\nAttached\n2023-08-10\nCRAN (R 4.3.0)\n\n\nreadr\n2.1.4\nAttached\n2023-02-10\nCRAN (R 4.3.0)\n\n\nstringr\n1.5.0\nAttached\n2022-12-02\nCRAN (R 4.3.0)\n\n\ntable1\n1.4.3\nAttached\n2023-01-06\nCRAN (R 4.3.0)\n\n\ntibble\n3.2.1\nAttached\n2023-03-20\nCRAN (R 4.3.0)\n\n\ntidyr\n1.3.0\nAttached\n2023-01-24\nCRAN (R 4.3.0)\n\n\ntidyverse\n2.0.0\nAttached\n2023-02-22\nCRAN (R 4.3.0)\n\n\nusethis\n2.2.2\nAttached\n2023-07-06\nCRAN (R 4.3.0)\n\n\nabind\n1.4-5\nLoaded\n2016-07-21\nCRAN (R 4.3.0)\n\n\nadaptMCMC\n1.4\nLoaded\n2021-03-29\nCRAN (R 4.3.0)\n\n\narm\n1.13-1\nLoaded\n2022-08-28\nCRAN (R 4.3.0)\n\n\nbackports\n1.4.1\nLoaded\n2021-12-13\nCRAN (R 4.3.0)\n\n\nBiocGenerics\n0.46.0\nLoaded\n2023-06-04\nBioconductor\n\n\nBiocManager\n1.30.22\nLoaded\n2023-08-08\nCRAN (R 4.3.0)\n\n\nbitops\n1.0-7\nLoaded\n2021-04-24\nCRAN (R 4.3.0)\n\n\nboot\n1.3-28.1\nLoaded\n2022-11-22\nCRAN (R 4.3.1)\n\n\nbroom\n1.0.5\nLoaded\n2023-06-09\nCRAN (R 4.3.0)\n\n\ncachem\n1.0.8\nLoaded\n2023-05-01\nCRAN (R 4.3.0)\n\n\ncallr\n3.7.3\nLoaded\n2022-11-02\nCRAN (R 4.3.0)\n\n\ncaTools\n1.18.2\nLoaded\n2021-03-28\nCRAN (R 4.3.0)\n\n\ncirclize\n0.4.15\nLoaded\n2022-05-10\nCRAN (R 4.3.0)\n\n\nclass\n7.3-22\nLoaded\n2023-05-03\nCRAN (R 4.3.1)\n\n\ncli\n3.6.1\nLoaded\n2023-03-23\nCRAN (R 4.3.0)\n\n\nclue\n0.3-65\nLoaded\n2023-09-23\nCRAN (R 4.3.1)\n\n\ncluster\n2.1.4\nLoaded\n2022-08-22\nCRAN (R 4.3.1)\n\n\ncoda\n0.19-4\nLoaded\n2020-09-30\nCRAN (R 4.3.0)\n\n\ncodetools\n0.2-19\nLoaded\n2023-02-01\nCRAN (R 4.3.1)\n\n\ncolorspace\n2.1-0\nLoaded\n2023-01-23\nCRAN (R 4.3.0)\n\n\nconquer\n1.3.3\nLoaded\n2023-03-06\nCRAN (R 4.3.0)\n\n\ncrayon\n1.5.2\nLoaded\n2022-09-29\nCRAN (R 4.3.0)\n\n\ndata.table\n1.14.8\nLoaded\n2023-02-17\nCRAN (R 4.3.0)\n\n\ndigest\n0.6.33\nLoaded\n2023-07-07\nCRAN (R 4.3.0)\n\n\ndoParallel\n1.0.17\nLoaded\n2022-02-07\nCRAN (R 4.3.0)\n\n\ne1071\n1.7-13\nLoaded\n2023-02-01\nCRAN (R 4.3.0)\n\n\nellipsis\n0.3.2\nLoaded\n2021-04-29\nCRAN (R 4.3.0)\n\n\nepiomics\n1.0.0\nLoaded\n2023-03-15\nCRAN (R 4.3.0)\n\n\nevaluate\n0.23\nLoaded\n2023-11-01\nCRAN (R 4.3.1)\n\n\nfansi\n1.0.5\nLoaded\n2023-10-08\nCRAN (R 4.3.1)\n\n\nfastmap\n1.1.1\nLoaded\n2023-02-24\nCRAN (R 4.3.0)\n\n\nfdrtool\n1.2.17\nLoaded\n2021-11-13\nCRAN (R 4.3.0)\n\n\nforeach\n1.5.2\nLoaded\n2022-02-02\nCRAN (R 4.3.0)\n\n\nFormula\n1.2-5\nLoaded\n2023-02-24\nCRAN (R 4.3.0)\n\n\nfs\n1.6.3\nLoaded\n2023-07-20\nCRAN (R 4.3.0)\n\n\ngenerics\n0.1.3\nLoaded\n2022-07-05\nCRAN (R 4.3.0)\n\n\nGetoptLong\n1.0.5\nLoaded\n2020-12-15\nCRAN (R 4.3.0)\n\n\nggrepel\n0.9.4\nLoaded\n2023-10-13\nCRAN (R 4.3.1)\n\n\nglasso\n1.11\nLoaded\n2019-10-01\nCRAN (R 4.3.0)\n\n\nglmnet\n4.1-8\nLoaded\n2023-08-22\nCRAN (R 4.3.0)\n\n\nGlobalOptions\n0.1.2\nLoaded\n2020-06-10\nCRAN (R 4.3.0)\n\n\nglue\n1.6.2\nLoaded\n2022-02-24\nCRAN (R 4.3.0)\n\n\ngplots\n3.1.3\nLoaded\n2022-04-25\nCRAN (R 4.3.0)\n\n\ngridExtra\n2.3\nLoaded\n2017-09-09\nCRAN (R 4.3.0)\n\n\ngtable\n0.3.4\nLoaded\n2023-08-21\nCRAN (R 4.3.0)\n\n\ngtools\n3.9.4\nLoaded\n2022-11-27\nCRAN (R 4.3.0)\n\n\nhdi\n0.1-9\nLoaded\n2021-05-27\nCRAN (R 4.3.0)\n\n\nHDMT\n1.0.5\nLoaded\n2022-01-29\nCRAN (R 4.3.0)\n\n\nhere\n1.0.1\nLoaded\n2020-12-13\nCRAN (R 4.3.0)\n\n\nHIMA\n2.2.1\nLoaded\n2023-09-10\nCRAN (R 4.3.0)\n\n\nhms\n1.1.3\nLoaded\n2023-03-21\nCRAN (R 4.3.0)\n\n\nhommel\n1.6\nLoaded\n2021-12-17\nCRAN (R 4.3.0)\n\n\nhtmltools\n0.5.6.1\nLoaded\n2023-10-06\nCRAN (R 4.3.1)\n\n\nhttpuv\n1.6.11\nLoaded\n2023-05-11\nCRAN (R 4.3.0)\n\n\nhttr\n1.4.7\nLoaded\n2023-08-15\nCRAN (R 4.3.0)\n\n\nigraph\n1.5.1\nLoaded\n2023-08-10\nCRAN (R 4.3.0)\n\n\nintervals\n0.15.4\nLoaded\n2023-06-29\nCRAN (R 4.3.0)\n\n\nIRanges\n2.34.1\nLoaded\n2023-07-02\nBioconductor\n\n\niterators\n1.0.14\nLoaded\n2022-02-05\nCRAN (R 4.3.0)\n\n\nKernSmooth\n2.23-22\nLoaded\n2023-07-10\nCRAN (R 4.3.0)\n\n\nknitr\n1.44\nLoaded\n2023-09-11\nCRAN (R 4.3.0)\n\n\nlars\n1.3\nLoaded\n2022-04-13\nCRAN (R 4.3.0)\n\n\nlater\n1.3.1\nLoaded\n2023-05-02\nCRAN (R 4.3.0)\n\n\nlattice\n0.21-9\nLoaded\n2023-10-01\nCRAN (R 4.3.1)\n\n\nlavaan\n0.6-16\nLoaded\n2023-07-19\nCRAN (R 4.3.0)\n\n\nlazyeval\n0.2.2\nLoaded\n2019-03-15\nCRAN (R 4.3.0)\n\n\nlbfgs\n1.2.1.2\nLoaded\n2022-06-23\nCRAN (R 4.3.0)\n\n\nlifecycle\n1.0.3\nLoaded\n2022-10-07\nCRAN (R 4.3.0)\n\n\nlinprog\n0.9-4\nLoaded\n2022-03-09\nCRAN (R 4.3.0)\n\n\nlme4\n1.1-34\nLoaded\n2023-07-04\nCRAN (R 4.3.0)\n\n\nlmerTest\n3.1-3\nLoaded\n2020-10-23\nCRAN (R 4.3.0)\n\n\nlpSolve\n5.6.19\nLoaded\n2023-09-13\nCRAN (R 4.3.0)\n\n\nmagrittr\n2.0.3\nLoaded\n2022-03-30\nCRAN (R 4.3.0)\n\n\nMASS\n7.3-60\nLoaded\n2023-05-04\nCRAN (R 4.3.1)\n\n\nMatrix\n1.6-1.1\nLoaded\n2023-09-18\nCRAN (R 4.3.1)\n\n\nMatrixModels\n0.5-2\nLoaded\n2023-07-10\nCRAN (R 4.3.0)\n\n\nmatrixStats\n1.0.0\nLoaded\n2023-06-02\nCRAN (R 4.3.0)\n\n\nmclust\n6.0.0\nLoaded\n2022-10-31\nCRAN (R 4.3.0)\n\n\nmemoise\n2.0.1\nLoaded\n2021-11-26\nCRAN (R 4.3.0)\n\n\nmime\n0.12\nLoaded\n2021-09-28\nCRAN (R 4.3.0)\n\n\nminiUI\n0.1.1.1\nLoaded\n2018-05-18\nCRAN (R 4.3.0)\n\n\nminqa\n1.2.6\nLoaded\n2023-09-11\nCRAN (R 4.3.0)\n\n\nmnormt\n2.1.1\nLoaded\n2022-09-26\nCRAN (R 4.3.0)\n\n\nmodelr\n0.1.11\nLoaded\n2023-03-22\nCRAN (R 4.3.0)\n\n\nmunsell\n0.5.0\nLoaded\n2018-06-12\nCRAN (R 4.3.0)\n\n\nncvreg\n3.14.1\nLoaded\n2023-04-25\nCRAN (R 4.3.0)\n\n\nnlme\n3.1-163\nLoaded\n2023-08-09\nCRAN (R 4.3.0)\n\n\nnloptr\n2.0.3\nLoaded\n2022-05-26\nCRAN (R 4.3.0)\n\n\nnnet\n7.3-19\nLoaded\n2023-05-03\nCRAN (R 4.3.1)\n\n\nnumDeriv\n2016.8-1.1\nLoaded\n2019-06-06\nCRAN (R 4.3.0)\n\n\nOpenMx\n2.21.8\nLoaded\n2023-04-05\nCRAN (R 4.3.0)\n\n\npbivnorm\n0.6.0\nLoaded\n2015-01-23\nCRAN (R 4.3.0)\n\n\npillar\n1.9.0\nLoaded\n2023-03-22\nCRAN (R 4.3.0)\n\n\npkgbuild\n1.4.2\nLoaded\n2023-06-26\nCRAN (R 4.3.0)\n\n\npkgconfig\n2.0.3\nLoaded\n2019-09-22\nCRAN (R 4.3.0)\n\n\npkgload\n1.3.3\nLoaded\n2023-09-22\nCRAN (R 4.3.1)\n\n\nplyr\n1.8.9\nLoaded\n2023-10-02\nCRAN (R 4.3.1)\n\n\npng\n0.1-8\nLoaded\n2022-11-29\nCRAN (R 4.3.0)\n\n\nprettyunits\n1.2.0\nLoaded\n2023-09-24\nCRAN (R 4.3.1)\n\n\nprocessx\n3.8.2\nLoaded\n2023-06-30\nCRAN (R 4.3.0)\n\n\nprofvis\n0.3.8\nLoaded\n2023-05-02\nCRAN (R 4.3.0)\n\n\nprogress\n1.2.2\nLoaded\n2019-05-16\nCRAN (R 4.3.0)\n\n\npromises\n1.2.1\nLoaded\n2023-08-10\nCRAN (R 4.3.0)\n\n\nproxy\n0.4-27\nLoaded\n2022-06-09\nCRAN (R 4.3.0)\n\n\nps\n1.7.5\nLoaded\n2023-04-18\nCRAN (R 4.3.0)\n\n\npscl\n1.5.5.1\nLoaded\n2023-05-10\nCRAN (R 4.3.0)\n\n\nqgcomp\n2.15.2\nLoaded\n2023-08-10\nCRAN (R 4.3.0)\n\n\nquadprog\n1.5-8\nLoaded\n2019-11-20\nCRAN (R 4.3.0)\n\n\nquantreg\n5.97\nLoaded\n2023-08-19\nCRAN (R 4.3.0)\n\n\nqvalue\n2.34.0\nLoaded\n2023-10-26\nBioconductor\n\n\nr.jive\n2.4\nLoaded\n2020-11-17\nCRAN (R 4.3.0)\n\n\nR6\n2.5.1\nLoaded\n2021-08-19\nCRAN (R 4.3.0)\n\n\nRColorBrewer\n1.1-3\nLoaded\n2022-04-03\nCRAN (R 4.3.0)\n\n\nRcpp\n1.0.11\nLoaded\n2023-07-06\nCRAN (R 4.3.0)\n\n\nRcppParallel\n5.1.7\nLoaded\n2023-02-27\nCRAN (R 4.3.0)\n\n\nremotes\n2.4.2.1\nLoaded\n2023-07-18\nCRAN (R 4.3.0)\n\n\nreshape2\n1.4.4\nLoaded\n2020-04-09\nCRAN (R 4.3.0)\n\n\nrjson\n0.2.21\nLoaded\n2022-01-09\nCRAN (R 4.3.0)\n\n\nrlang\n1.1.1\nLoaded\n2023-04-28\nCRAN (R 4.3.0)\n\n\nrmarkdown\n2.25\nLoaded\n2023-09-18\nCRAN (R 4.3.1)\n\n\nRMediation\n1.2.2\nLoaded\n2023-05-12\nCRAN (R 4.3.0)\n\n\nrprojroot\n2.0.3\nLoaded\n2022-04-02\nCRAN (R 4.3.0)\n\n\nrstudioapi\n0.15.0\nLoaded\n2023-07-07\nCRAN (R 4.3.0)\n\n\nS4Vectors\n0.38.2\nLoaded\n2023-09-24\nBioconductor\n\n\nscales\n1.2.1\nLoaded\n2022-08-20\nCRAN (R 4.3.0)\n\n\nscalreg\n1.0.1\nLoaded\n2019-01-25\nCRAN (R 4.3.0)\n\n\nselectiveInference\n1.2.5\nLoaded\n2019-09-07\nCRAN (R 4.3.0)\n\n\nsessioninfo\n1.2.2\nLoaded\n2021-12-06\nCRAN (R 4.3.0)\n\n\nshape\n1.4.6\nLoaded\n2021-05-19\nCRAN (R 4.3.0)\n\n\nshiny\n1.7.5.1\nLoaded\n2023-10-14\nCRAN (R 4.3.1)\n\n\nSparseM\n1.81\nLoaded\n2021-02-18\nCRAN (R 4.3.0)\n\n\nstringi\n1.7.12\nLoaded\n2023-01-11\nCRAN (R 4.3.0)\n\n\nsurvival\n3.5-7\nLoaded\n2023-08-14\nCRAN (R 4.3.0)\n\n\ntidyselect\n1.2.0\nLoaded\n2022-10-10\nCRAN (R 4.3.0)\n\n\ntimechange\n0.2.0\nLoaded\n2023-01-11\nCRAN (R 4.3.0)\n\n\ntzdb\n0.4.0\nLoaded\n2023-05-12\nCRAN (R 4.3.0)\n\n\nurlchecker\n1.0.1\nLoaded\n2021-11-30\nCRAN (R 4.3.0)\n\n\nutf8\n1.2.4\nLoaded\n2023-10-22\nCRAN (R 4.3.1)\n\n\nvctrs\n0.6.4\nLoaded\n2023-10-12\nCRAN (R 4.3.1)\n\n\nviridisLite\n0.4.2\nLoaded\n2023-05-02\nCRAN (R 4.3.0)\n\n\nwithr\n2.5.2\nLoaded\n2023-10-30\nCRAN (R 4.3.1)\n\n\nxfun\n0.40\nLoaded\n2023-08-09\nCRAN (R 4.3.0)\n\n\nxtable\n1.8-4\nLoaded\n2019-04-21\nCRAN (R 4.3.0)\n\n\nxtune\n2.0.0\nLoaded\n2023-06-18\nCRAN (R 4.3.0)\n\n\nyaml\n2.3.7\nLoaded\n2023-01-23\nCRAN (R 4.3.0)"
  },
  {
    "objectID": "software.html#software-environment",
    "href": "software.html#software-environment",
    "title": "5  Software",
    "section": "5.3 Software Environment",
    "text": "5.3 Software Environment\nThis book was developed on the following platform.\n\n\n\n\n\n\n\nSetting\nValue\n\n\n\n\nversion\nR version 4.3.1 (2023-06-16)\n\n\nos\nmacOS Sonoma 14.1\n\n\nsystem\naarch64, darwin20\n\n\nui\nX11\n\n\nlanguage\n(EN)\n\n\ncollate\nen_US.UTF-8\n\n\nctype\nen_US.UTF-8\n\n\ntz\nAmerica/Los_Angeles\n\n\ndate\n2023-11-02\n\n\npandoc\n3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)"
  },
  {
    "objectID": "appendix_code.html#code-for-plotting-integratedquasi-mediation-analysis-results",
    "href": "appendix_code.html#code-for-plotting-integratedquasi-mediation-analysis-results",
    "title": "6  Supplemental Code",
    "section": "6.1 Code for plotting Integrated/Quasi Mediation Analysis Results",
    "text": "6.1 Code for plotting Integrated/Quasi Mediation Analysis Results\nThe following code is provided as an example of how to plot the results of the integrated/quasi-mediation analysis. Since the results of these models depend critically upon the structure of the data used for the models, these functions may require alterations to obtain informative figures when analyzing other datasets.\n\n6.1.1 Early Integration of omics datasets\n\n\nCode\n#' Plot Sankey Diagram for LUCID in Early integration\n#' \n#' Given an object of class from LUCID\n#'\n#' @param lucid_fit1  an object of class from LUCID\n#' @param text_size  size of the text in sankey diagram\n#'\n#' @return a Sankey Diagram for LUCID in Early integration\n#'\n#' @import dplyr\n#' @importFrom ggplot2 ggplot\n\n\n\nsankey_early_integration &lt;- function(lucid_fit1, text_size = 15) {\n  # Get sankey dataframe ----\n  get_sankey_df &lt;- function(x,\n                            G_color = \"dimgray\", \n                            X_color = \"#eb8c30\",\n                            Z_color = \"#2fa4da\", \n                            Y_color = \"#afa58e\", \n                            pos_link_color = \"#67928b\", \n                            neg_link_color = \"#d1e5eb\", \n                            fontsize = 10) {\n    K &lt;- x$K\n    var.names &lt;- x$var.names\n    dimG &lt;- length(var.names$Gnames)\n    dimZ &lt;- length(var.names$Znames)\n    valueGtoX &lt;- as.vector(t(x$res_Beta[, -1]))\n    valueXtoZ &lt;- as.vector(t(x$res_Mu))\n    valueXtoY &lt;- as.vector(x$res_Gamma$beta)[1:K]\n    \n    # GtoX\n    GtoX &lt;- data.frame(\n      source = rep(x$var.names$Gnames, K), \n      target = paste0(\"Latent Cluster\", \n                      as.vector(sapply(1:K, function(x) rep(x, dimG)))), \n      value = abs(valueGtoX), \n      group = as.factor(valueGtoX &gt; 0))\n    \n    # XtoZ\n    XtoZ &lt;- data.frame(\n      source = paste0(\"Latent Cluster\", \n                      as.vector(sapply(1:K, \n                                       function(x) rep(x, dimZ)))), \n      target = rep(var.names$Znames, \n                   K), value = abs(valueXtoZ),\n      group = as.factor(valueXtoZ &gt; \n                          0))\n    \n    # subset top 25% of each omics layer\n    top25&lt;- XtoZ %&gt;%\n      filter(source == \"Latent Cluster1\") %&gt;%\n      mutate(omics = case_when(grepl(\"cg\", target) ~ \"Methylation\",\n                               grepl(\"tc\", target) ~ \"Transcriptome\",\n                               grepl(\"miR\", target) ~ \"miRNA\")) %&gt;%\n      group_by(omics) %&gt;%\n      arrange(desc(value)) %&gt;%\n      slice(1:7) %&gt;%\n      ungroup()\n    \n    XtoZ_sub&lt;- XtoZ %&gt;%\n      filter(target %in% top25$target)\n    \n    \n    # XtoY\n    XtoY &lt;- data.frame(source = paste0(\"Latent Cluster\", 1:K), \n                       target = rep(var.names$Ynames, K), value = abs(valueXtoY), \n                       group = as.factor(valueXtoY &gt; 0))\n    links &lt;- rbind(GtoX, XtoZ_sub, XtoY)\n    # links &lt;- rbind(GtoX, XtoZ, XtoY)\n    \n    nodes &lt;- data.frame(\n      name = unique(c(as.character(links$source), \n                      as.character(links$target))), \n      group = as.factor(c(rep(\"exposure\",\n                              dimG), rep(\"lc\", K), rep(\"biomarker\", nrow(XtoZ_sub)/2), \"outcome\")))\n    # group = as.factor(c(rep(\"exposure\", \n    # dimG), rep(\"lc\", K), rep(\"biomarker\", dimZ), \"outcome\")))\n    ## the following two lines were used to exclude covars from the plot\n    links &lt;- links %&gt;% filter(!grepl(\"cohort\", source) & \n                                !grepl(\"age\", source) & \n                                !grepl(\"fish\", source) &\n                                !grepl(\"sex\", source))\n    nodes &lt;- nodes %&gt;% filter(!grepl(\"cohort\", name) &\n                                !grepl(\"age\", name) & \n                                !grepl(\"fish\", name) &\n                                !grepl(\"sex\", name)) \n    \n    links$IDsource &lt;- match(links$source, nodes$name) - 1\n    links$IDtarget &lt;- match(links$target, nodes$name) - 1\n    \n    color_scale &lt;- data.frame(\n      domain = c(\"exposure\", \"lc\", \"biomarker\", \n                 \"outcome\", \"TRUE\", \"FALSE\"), \n      range = c(G_color, X_color, \n                Z_color, Y_color, pos_link_color, neg_link_color))\n    \n    sankey_df = list(links = links, \n                     nodes = nodes)\n    return(sankey_df)\n  }\n  # 1. Get sankey dataframes ----\n  sankey_dat &lt;- get_sankey_df(lucid_fit1)\n  n_omics &lt;- length(lucid_fit1$var.names$Znames)\n  # link data\n  links &lt;- sankey_dat[[\"links\"]] \n  # node data\n  nodes &lt;- sankey_dat[[\"nodes\"]] \n  \n  nodes1 &lt;- nodes %&gt;% \n    mutate(group = case_when(str_detect(name,\"Cluster\") ~ \"lc\",\n                             str_detect(name, \"cg\") ~ \"CpG\",\n                             str_detect(name, \"outcome\") ~ \"outcome\",\n                             str_detect(name, \"pro\") ~ \"Prot\",\n                             str_detect(name, \"met\") ~ \"Met\",\n                             str_detect(name, \"tc\") ~ \"TC\",\n                             str_detect(name, \"miR\") ~ \"miRNA\",\n                             str_detect(name, \"G1\") ~ \"exposure\"),\n           name = ifelse(name == \"G1\", \"Hg\",name))\n  links1 &lt;- links %&gt;%\n    mutate(source = ifelse(source == \"G1\", \"Hg\",source))\n  # 6. Plotly Version ----\n  \n  ## 6.1 Set Node Color Scheme: ----\n  color_pal_sankey &lt;- matrix(\n    c(\"exposure\", sankey_colors$range[sankey_colors$domain == \"exposure\"],\n      \"lc\",       \"#b3d8ff\",\n      \"CpG\",     sankey_colors$range[sankey_colors$domain == \"layer1\"],\n      \"TC\",      sankey_colors$range[sankey_colors$domain == \"layer2\"],\n      \"miRNA\", sankey_colors$range[sankey_colors$domain == \"layer3\"],\n      \"outcome\",  sankey_colors$range[sankey_colors$domain == \"Outcome\"]), \n    ncol = 2, byrow = TRUE) %&gt;%\n    as_tibble(.name_repair = \"unique\") %&gt;% \n    janitor::clean_names() %&gt;%\n    dplyr::rename(group = x1, color = x2)\n  \n  # Add color scheme to nodes\n  nodes_new_plotly &lt;- nodes1 %&gt;% \n    left_join(color_pal_sankey) %&gt;%\n    mutate(\n      x = case_when(\n        group == \"exposure\" ~ 0,\n        str_detect(name, \"Cluster\") ~ 1/3,\n        str_detect(name, \"cg\")|\n          str_detect(name, \"tc\")|\n          str_detect(name, \"miR\")|\n          str_detect(name, \"outcome\")~ 2/3\n      ))\n  \n  nodes_new_plotly1 &lt;- nodes_new_plotly %&gt;%\n    # Modify names of features for plotting\n   dplyr::select(group, color, x, name)%&gt;% \n    mutate(name = case_when(name == \"value\" ~ \"&lt;b&gt;Hg&lt;/b&gt;\",\n                            name == \"Latent Cluster1\" ~ \"&lt;b&gt;Joint Omics\\nProfile 0&lt;/b&gt;\",\n                            name == \"Latent Cluster2\" ~ \"&lt;b&gt;Joint Omics\\nProfile 1&lt;/b&gt;\",\n                            TRUE ~ name))\n    \n  \n  ## 6.2 Get links for Plotly, set color ----\n  links_new &lt;- links1  %&gt;%\n    mutate(\n      link_color = case_when(\n        # Ref link color\n        value == 0 ~     \"#f3f6f4\",\n        # # Cluster \n        # str_detect(source, \"Cluster1\") &  group == TRUE  ~  \"#706C6C\",\n        # str_detect(source, \"Cluster1\") &  group == FALSE ~  \"#D3D3D3\",\n        # str_detect(source, \"Cluster2\") &  group == TRUE  ~  \"#706C6C\",\n        # str_detect(source, \"Cluster2\") &  group == FALSE ~  \"#D3D3D3\",\n        ##############\n        # Exposure\n        str_detect(source, \"Hg\") &  group == TRUE  ~  \"red\",\n            # Outcome\n        str_detect(target, \"outcome\") &  group == TRUE  ~  \"red\",\n        # Methylation \n        str_detect(target, \"tc\") &  group == TRUE  ~  \"#bf9000\",\n        str_detect(target, \"tc\") &  group == FALSE ~  \"#ffd966\",\n        # Transcriptome\n        str_detect(target, \"cg\") &  group == TRUE  ~  \"#38761d\",\n        str_detect(target, \"cg\") &  group == FALSE ~  \"#b6d7a8\",\n        # proteome\n        str_detect(target, \"miR\") &  group == TRUE  ~  \"#a64d79\",\n        str_detect(target, \"miR\") &  group == FALSE ~  \"#ead1dc\",\n        ##\n        group == FALSE ~ \"#D3D3D3\", # Negative association\n        group == TRUE ~  \"#706C6C\")) # Positive association\n  \n  links_new1&lt;- links_new %&gt;%\n   dplyr::select(colnames(links_new), target)\n    \n  plotly_link &lt;- list(\n    source = links_new1$IDsource,\n    target = links_new1$IDtarget,\n    value = links_new1$value+.00000000000000000000001, \n    color = links_new1$link_color)  \n  \n  # Get list of nodes for Plotly\n  plotly_node &lt;- list(\n    label = nodes_new_plotly1$name, \n    color = nodes_new_plotly1$color,\n    pad = 15,\n    thickness = 20,\n    line = list(color = \"black\",width = 0.5),\n    x = nodes_new_plotly1$x, \n    # y = c(0.01, \n    #       0.3, 0.7, # clusters\n    #       seq(from = .01, to = 1, by = 0.04)[1:(dimZ * 0.25)], # biomaker\n    #       .95\n    y = c(0.01,\n          0.1, 0.5, # clusters\n          seq(from = .05, to = 1, by = 0.04)[1:21],\n          # seq(from = (.01+0.06*7), to = 1, by = 0.08)[1:5],\n          # 0.9,\n          # biomaker\n          0.98\n  ))\n  \n  \n  ## 6.3 Plot Figure ----\n  (fig &lt;- plot_ly(\n    type = \"sankey\",\n    domain = list(\n      x =  c(0,1),\n      y =  c(0,1)),\n    orientation = \"h\",\n    node = plotly_node,\n    link = plotly_link))\n  \n  (fig &lt;- fig %&gt;% layout(\n    # title = \"Basic Sankey Diagram\",\n    font = list(\n      size = text_size\n    ))\n  )\n  return(fig)\n}\n\n\n\n\n6.1.2 Intermediate Integration of omics datasets\n\n\nCode\n#' Plot Sankey Diagram for LUCID in parallel\n#' @param lucidus_fit  an object of class from LUCID\n#' @param sankey_colors a matrix including colors for each item in related sankey diagram\n#' @param text_size  size of the text in sankey diagram\n#' @param n_z_ftrs_to_plot an vector with numbers of features to show \n#' in the sankey diagram for each omic layer\n#' \n#' @return a Sankey Diagram for LUCID in parallel\n#'\n#' @import dplyr\n#' @importFrom ggplot2 ggplot\n#' @importFrom purrr map\n#' @importFrom tidyr as_tibble\n#' @importFrom dplyr left_join\nplot_lucid_in_parallel_plotly&lt;- function(lucidus_fit,\n                                         sankey_colors,\n                                         text_size = 10, \n                                         n_z_ftrs_to_plot = NULL){\n  # Get number of clusters, layers, etc.\n  K &lt;- lucidus_fit$K\n  dimG &lt;- lucidus_fit$res_Beta$Beta[[1]] %&gt;% ncol()-1\n  n_layers   &lt;- length(lucidus_fit$res_Beta$Beta)\n  \n  # Get top omics features based on effect size\n  if(!is.null(n_z_ftrs_to_plot)){\n    top_ftrs &lt;- vector(\"list\", n_layers)\n    for(i in seq_along(top_ftrs)){\n      top_ftrs[[i]] &lt;- lucidus_fit$res_Mu[[i]] %&gt;%\n        as.data.frame() %&gt;%\n        rownames_to_column(\"name\") %&gt;%\n        mutate(effect_size = abs(V1) + abs(V2)) %&gt;%\n        arrange(desc(effect_size))\n      top_ftr_nms &lt;- top_ftrs[[i]]$name[1:n_z_ftrs_to_plot[i]]\n      lucidus_fit$res_Mu[[i]] &lt;- \n        lucidus_fit$res_Mu[[i]][\n          rownames(lucidus_fit$res_Mu[[i]]) %in% top_ftr_nms, ]\n    }\n  }\n  \n  mu_lst &lt;- purrr::map(lucidus_fit$res_Mu, \n                       ~as.data.frame(.x) %&gt;%\n                         rownames_to_column(\"name\"))\n  names(mu_lst) &lt;- paste0(\"layer\", c(1:n_layers))\n  dimZ &lt;- purrr::map(mu_lst, ncol) %&gt;% as.numeric()-1\n  n_features &lt;- purrr::map(mu_lst, nrow) %&gt;% as.numeric()\n  names(n_features) &lt;- paste0(\"layer\", c(1:n_layers))\n  # Names of features and set order of omics features\n  names_features &lt;- bind_rows(mu_lst, .id = \"color_group\") %&gt;% \n    rowwise() %&gt;%\n    mutate(sum = sum(abs(V1)+abs(V2)), \n           pos_c2 = if_else(V2&gt;0, \"pos\", \"neg\")) %&gt;%\n    group_by(color_group, pos_c2) %&gt;% arrange(-sum, .by_group = TRUE) %&gt;% ungroup() %&gt;% \n    mutate(rnum = row_number()) %&gt;%\n    group_by(name) %&gt;% slice_head() %&gt;% ungroup() %&gt;%\n    arrange(color_group, rnum) %&gt;%\n    dplyr::select(name, color_group)\n  \n  # Values for g --&gt; x association\n  valueGtoX &lt;- c(lapply(lucidus_fit$res_Beta$Beta, \n                        function(x)(x[-1])) %&gt;%\n                   unlist(), \n                 rep(0, dimG*n_layers))\n  \n  # For Cluster 2 (which needs effect estimates): \n  valueGtoX_c1 &lt;- do.call(rbind, lucidus_fit$res_Beta$Beta)[,-1] %&gt;%\n    as_tibble() %&gt;%\n    dplyr::mutate(layer = str_c(\"(Layer \", row_number(), \")\"),\n                  cluster = \"Cluster 2\") \n  \n  # For cluster 1 (ref. cluster, effect est = 0):\n  valueGtoX_c2 &lt;- valueGtoX_c1 %&gt;%\n    mutate(across(where(is.numeric), ~0), \n           cluster = \"Cluster 1\")\n  \n  # combine, pivot longer, and create source and target columns\n  GtoX &lt;- bind_rows(valueGtoX_c1, valueGtoX_c2) %&gt;%\n    mutate(target = str_c(cluster, layer, sep = \" \")) %&gt;%\n    pivot_longer(cols = setdiff(colnames(valueGtoX_c1), \n                                c(\"layer\", \"cluster\")), \n                 names_to = \"source\", values_to = \"value\") %&gt;%\n    mutate(color_group = as.factor(value &gt; 0), \n           value = abs(value)) %&gt;%\n    dplyr::select(source, target, value, color_group) %&gt;%\n    as.data.frame()\n  \n  valueXtoZ &lt;- c(lapply(lucidus_fit$res_Mu, \n                        function(x)x[, 1]) %&gt;% \n                   unlist(), \n                 lapply(lucidus_fit$res_Mu, \n                        function(x)x[, 2]) %&gt;% \n                   unlist())\n  \n  valueXtoY &lt;- c(rep(0, n_layers), \n                 # rep(lucidus_fit$res_Delta$Delta$mu[1] / n_layers, n_layers),\n                 lucidus_fit$res_Gamma$Gamma$mu[-1])\n  \n  # n features in each layer\n  XtoZ &lt;- data.frame(source = c(rep(\"Cluster 1 (Layer 1)\", n_features[1]),\n                                rep(\"Cluster 1 (Layer 2)\", n_features[2]),\n                                rep(\"Cluster 1 (Layer 3)\", n_features[3]),\n                                # rep(\"Cluster 1 (Layer 4)\", n_features[4]),\n                                rep(\"Cluster 2 (Layer 1)\", n_features[1]),\n                                rep(\"Cluster 2 (Layer 2)\", n_features[2]),\n                                rep(\"Cluster 2 (Layer 3)\", n_features[3]) \n                                # rep(\"Cluster 2 (Layer 4)\", n_features[4])\n  ), \n  target = rep(c(lapply(lucidus_fit$res_Mu,\n                        rownames) %&gt;% unlist()),\n               K[1]), \n  value = abs(valueXtoZ), \n  color_group = as.factor(valueXtoZ &gt; 0))\n  \n  # To change the outcome from left to right hand side, flip source and target\n  XtoY &lt;- data.frame(target = rep(\"Outcome\", 2*n_layers), \n                     source = c(\"Cluster 1 (Layer 1)\", \n                                \"Cluster 1 (Layer 2)\",\n                                \"Cluster 1 (Layer 3)\",\n                                # \"Cluster 1 (Layer 4)\",\n                                \"Cluster 2 (Layer 1)\",\n                                \"Cluster 2 (Layer 2)\",\n                                \"Cluster 2 (Layer 3)\" \n                                # \"Cluster 2 (Layer 4)\"\n                     ), \n                     value = abs(valueXtoY), \n                     color_group = as.factor(valueXtoY &gt; 0))\n  \n  # create Sankey diagram\n  # Create Links ----\n  links &lt;- rbind(GtoX, XtoZ, XtoY) %&gt;%\n    mutate(\n      # Group: one of exposure, clusters, or outcomes \n      # (doesn't include Z.order by desired order)\n      source_group = case_when(\n        str_detect(source, \"Cluster\") ~ \"2_Cluster\", \n        # source == \"Outcome\" ~ \"3_outcome\", # removed when moving outcome to right\n        TRUE ~ \"1_exposure\"), \n      # Source Omics Layer: lc1-lc4 (for omics layers), outcome, or other \n      source_layer = case_when(\n        str_detect(source, \"Layer 1\") ~ \"lc1\", \n        str_detect(source, \"Layer 2\") ~ \"lc2\", \n        str_detect(source, \"Layer 3\") ~ \"lc3\", \n        str_detect(source, \"Layer 4\") ~ \"lc4\",\n        # source == \"Outcome\" ~ str_sub(target, start = -3, end = -2),  # removed when moving outcome to right\n        TRUE ~ \"exposure\"), \n      # Source group_ for color (one of: exposure, : lc1-lc4 (for omics layers), outcome, or other \n      color_group_node = if_else(source == \"Outcome\", \n                                 \"Outcome\", \n                                 source_layer)) %&gt;%\n    group_by(source_group) %&gt;%\n    arrange(source_layer, .by_group = TRUE) %&gt;%\n    ungroup() %&gt;%\n    dplyr::select(source, target, value, color_group, color_group_node)\n  \n  \n  # Create Nodes ----\n  nodes &lt;- links %&gt;%\n    dplyr::select(source, color_group_node) %&gt;%\n    mutate(rownum = row_number()) %&gt;%\n    rename(name = source, \n           color_group = color_group_node) %&gt;%\n    # Add outcome (only if outcome is on right side)\n    bind_rows(data.frame(name = \"Outcome\", color_group = \"Outcome\")) %&gt;%\n    group_by(name) %&gt;%\n    slice_head() %&gt;%\n    ungroup() %&gt;%\n    arrange(rownum) %&gt;%\n    dplyr::select(-rownum) %&gt;%\n    # Add feature names\n    bind_rows(names_features) %&gt;% \n    mutate(id = row_number()-1) %&gt;%\n    left_join(sankey_colors, by = c( \"color_group\"= \"domain\"))\n  \n  # Join links and nodes for color names -----\n  links &lt;- links %&gt;%\n    left_join(nodes %&gt;% \n                dplyr::select(id, name), \n              by = c(\"source\" = \"name\")) %&gt;%\n    rename(source_id = id) %&gt;% \n    dplyr::select(source_id, everything()) %&gt;%\n    left_join(nodes %&gt;% \n                dplyr::select(id, name), \n              by = c(\"target\" = \"name\")) %&gt;%\n    rename(target_id = id) %&gt;% \n    dplyr::select(source_id,source, target_id,everything()) \n  \n  \n  # Manually change colors ----\n  links &lt;- links  %&gt;%\n    mutate(\n      link_color = case_when(\n        # Ref link color\n        value == 0 ~     \"#f3f6f4\", \n        # Outcome\n        str_detect(target, \"Outcome\") &  color_group == TRUE  ~  \"red\",\n        # Methylation \n        str_detect(source, \"Layer 2\") &  color_group == TRUE  ~  \"#bf9000\",\n        str_detect(source, \"Layer 2\") &  color_group == FALSE ~  \"#ffd966\",\n        # Transcriptome\n        str_detect(source, \"Layer 1\") &  color_group == TRUE  ~  \"#38761d\",\n        str_detect(source, \"Layer 1\") &  color_group == FALSE ~  \"#b6d7a8\",\n        # mirna\n        str_detect(source, \"Layer 3\") &  color_group == TRUE  ~  \"#a64d79\",\n        str_detect(source, \"Layer 3\") &  color_group == FALSE ~  \"#ead1dc\",\n        \n        links$color_group == FALSE ~ \"#d9d2e9\", # Negative association\n        links$color_group == TRUE ~  \"red\"))\n  \n  ## change node names\n  nodes &lt;- nodes %&gt;%\n    mutate(name = case_when(name == \"value\" ~ \"&lt;b&gt;Hg&lt;/b&gt;\",\n                            name == \"Cluster 1 (Layer 1)\" ~ \"&lt;b&gt;Methylation\\nProfile 0&lt;/b&gt;\",\n                            name == \"Cluster 2 (Layer 1)\" ~ \"&lt;b&gt;Methylation\\nProfile 1&lt;/b&gt;\",\n                            name == \"Cluster 1 (Layer 2)\" ~ \"&lt;b&gt;Transcriptome\\nProfile 0&lt;/b&gt;\",\n                            name == \"Cluster 2 (Layer 2)\" ~ \"&lt;b&gt;Transcriptome\\nProfile 1&lt;/b&gt;\",\n                            name == \"Cluster 1 (Layer 3)\" ~ \"&lt;b&gt;miRNA\\nProfile 0&lt;/b&gt;\",\n                            name == \"Cluster 2 (Layer 3)\" ~ \"&lt;b&gt;miRNA\\nProfile 1&lt;/b&gt;\",\n                            TRUE ~ name),\n           x = case_when(\n             name == \"Hg\" ~ 0,\n             str_detect(name, \"Methylation\") |\n               str_detect(name, \"Transcript\") | \n               str_detect(name, \"miRNA\") ~ 1/3, \n             str_detect(name, \"cg\")|\n               str_detect(name, \"tc\")|\n               str_detect(name, \"miR\")| \n               str_detect(name, \"Outcome\") ~ 2/3))\n  \n  (fig &lt;- plot_ly(\n    type = \"sankey\",\n    orientation = \"h\",\n    domain = list(\n      x =  c(0,0.8),\n      y =  c(0,1)),\n    # arrangement = \"snap\",\n    node = list(\n      label = nodes$name,\n      color = nodes$range,\n      pad = 15,\n      thickness = 20,\n      line = list(\n        color = \"black\",\n        width = 0.5\n      ),\n      x = nodes$x\n    ),\n    \n    link = list(\n      source = links$source_id,\n      target = links$target_id,\n      value =  links$value+.00000000000000000000001,\n      # label = links$source,\n      color = links$link_color\n    )\n  )\n  )\n  \n  fig &lt;- fig %&gt;% layout(\n    font = list(\n      size = text_size\n    ),\n    xaxis = list(showgrid = F, zeroline = F),\n    yaxis = list(showgrid = F, zeroline = F)\n  )\n  \n  fig\n}\n\n\n\n# Set Color Palettes \ncol_pal &lt;- RColorBrewer::brewer.pal(n = 8, name = \"Dark2\")\n\n# Set Sankey Colors ----\n# Color pallet for sankey diagrams\nsankey_colors &lt;- matrix(c(\"exposure\", col_pal[6],\n                          \"lc1\",      col_pal[1],\n                          \"lc2\",      col_pal[2],\n                          \"lc3\",      col_pal[3],\n                          \"lc4\",      col_pal[4],\n                          \"layer1\",   col_pal[1],\n                          \"layer2\",   col_pal[2],\n                          \"layer3\",   col_pal[3],\n                          \"layer4\",   col_pal[4],\n                          \"Outcome\",  col_pal[8],\n                          \"TRUE\",     \"#6372e0\", # Blue\n                          \"FALSE\",    \"#d1d4ff\", # Light grey\n                          \"pos_clus_to_out\", \"red\", \n                          \"neg_clus_to_out\", \"#e4e5f2\"), \n                        byrow = TRUE, nrow = 14)\n\n# Change to dataframe\ncolnames(sankey_colors) &lt;- c(\"domain\", \"range\")\nsankey_colors &lt;- as.data.frame(sankey_colors)\n\n\n\n\n6.1.3 Late Integration of omics datasets\n\n\nCode\n#' Plot Sankey Diagram for LUCID in late integration\n\n# Get sankey dataframe\nget_sankey_df &lt;- function(x,\n                          G_color = \"dimgray\", \n                          X_color = \"#eb8c30\",\n                          Z_color = \"#2fa4da\", \n                          Y_color = \"#afa58e\", \n                          pos_link_color = \"#67928b\", \n                          neg_link_color = \"#d1e5eb\", \n                          fontsize = 7) {\n  K &lt;- x$K\n  var.names &lt;- x$var.names\n  pars &lt;- x$pars\n  dimG &lt;- length(var.names$Gnames)\n  dimZ &lt;- length(var.names$Znames)\n  valueGtoX &lt;- as.vector(t(x$res_Beta[, -1]))\n  valueXtoZ &lt;- as.vector(t(x$res_Mu))\n  valueXtoY &lt;- as.vector(x$res_Gamma$beta)[1:K]\n  \n  # GtoX\n  GtoX &lt;- data.frame(\n    source = rep(x$var.names$Gnames, K), \n    target = paste0(\"Latent Cluster\", \n                    as.vector(sapply(1:K, function(x) rep(x, dimG)))), \n    value = abs(valueGtoX), \n    group = as.factor(valueGtoX &gt; 0))\n  \n  # XtoZ\n  XtoZ &lt;- data.frame(\n    source = paste0(\"Latent Cluster\", \n                    as.vector(sapply(1:K, \n                                     function(x) rep(x, dimZ)))), \n    target = rep(var.names$Znames, \n                 K), value = abs(valueXtoZ),\n    group = as.factor(valueXtoZ &gt; \n                        0))\n  # XtoY\n  XtoY &lt;- data.frame(source = paste0(\"Latent Cluster\", 1:K), \n                     target = rep(var.names$Ynames, K), value = abs(valueXtoY), \n                     group = as.factor(valueXtoY &gt; 0))\n  \n  links &lt;- rbind(GtoX, XtoZ, XtoY)\n  \n  nodes &lt;- data.frame(\n    name = unique(c(as.character(links$source), \n                    as.character(links$target))), \n    group = as.factor(c(rep(\"exposure\", \n                            dimG), rep(\"lc\", K), rep(\"biomarker\", dimZ), \"outcome\")))\n  \n  ## the following two lines were used to exclude covars from the plot \n  links &lt;- links %&gt;% filter(!grepl(\"cohort\", source) & \n                              !grepl(\"age\", source) & \n                              !grepl(\"fish\", source) &\n                              !grepl(\"sex\", source))\n  nodes &lt;- nodes %&gt;% filter(!grepl(\"cohort\", name) &\n                              !grepl(\"age\", name) & \n                              !grepl(\"fish\", name) &\n                              !grepl(\"sex\", name))  \n  \n  \n  links$IDsource &lt;- match(links$source, nodes$name) - 1\n  links$IDtarget &lt;- match(links$target, nodes$name) - 1\n  \n  color_scale &lt;- data.frame(\n    domain = c(\"exposure\", \"lc\", \"biomarker\", \n               \"outcome\", \"TRUE\", \"FALSE\"), \n    range = c(G_color, X_color, \n              Z_color, Y_color, pos_link_color, neg_link_color))\n  \n  sankey_df = list(links = links, \n                   nodes = nodes)\n  \n  # p &lt;- sankeyNetwork(\n  #   Links = sankey_df$links, \n  #   Nodes = sankey_df$nodes, \n  #   Source = \"IDsource\", \n  #   Target = \"IDtarget\",\n  #   Value = \"value\", \n  #   NodeID = \"name\", \n  #   colourScale = JS(sprintf(\"d3.scaleOrdinal()\\n .domain(%s)\\n .range(%s)\\n \", \n  #                            jsonlite::toJSON(color_scale$domain), \n  #                            jsonlite::toJSON(color_scale$range))), \n  #   LinkGroup = \"group\", \n  #   NodeGroup = \"group\", \n  #   sinksRight = FALSE, \n  #   fontSize = fontsize)\n  # p\n  return(sankey_df)\n}\n\n\n# sankey_in_serial Function ----\nsankey_in_serial &lt;- function(lucid_fit1, lucid_fit2, lucid_fit3, color_pal_sankey, text_size = 15) {\n  \n  # 1. Get sankey dataframes ----\n  sankey_dat1 &lt;- get_sankey_df(lucid_fit1)\n  sankey_dat2 &lt;- get_sankey_df(lucid_fit2)\n  sankey_dat3 &lt;- get_sankey_df(lucid_fit3)\n  \n  n_omics_1 &lt;- length(lucid_fit1$var.names$Znames)\n  n_omics_2 &lt;- length(lucid_fit2$var.names$Znames)\n  n_omics_3 &lt;- length(lucid_fit3$var.names$Znames)\n  \n  # combine link data\n  lnks1_methylation &lt;- sankey_dat1[[\"links\"]] %&gt;% mutate(analysis = \"1_methylation\")\n  lnks2_miRNA  &lt;- sankey_dat2[[\"links\"]] %&gt;% mutate(analysis = \"2_miRNA\")\n  lnks3_transcription    &lt;- sankey_dat3[[\"links\"]] %&gt;% mutate(analysis = \"3_transcript\")\n  links &lt;- bind_rows(lnks1_methylation, lnks2_miRNA, lnks3_transcription)\n  \n  # combine node data\n  nodes1_methylation &lt;- sankey_dat1[[\"nodes\"]] %&gt;% mutate(analysis = \"1_methylation\")\n  nodes2_miRNA  &lt;- sankey_dat2[[\"nodes\"]] %&gt;% mutate(analysis = \"2_miRNA\")\n  nodes3_transcription    &lt;- sankey_dat3[[\"nodes\"]] %&gt;% mutate(analysis = \"3_transcript\")\n  nodes &lt;- bind_rows(nodes1_methylation, nodes2_miRNA, nodes3_transcription)\n  \n  \n  # 2. Modify analysis 1 ----\n  # For analysis 1, latent clusters need to be renamed to names from analysis 2:\n  ## 2.1 Get new and original latent cluster names (from the next analysis) ----\n  names_clusters_1 &lt;- data.frame(\n    name_og = c(\"Latent Cluster1\", \"Latent Cluster2\"), \n    name_new = c(\"&lt;b&gt;Methylation\\nProfile 0&lt;/b&gt;\", \"&lt;b&gt;Methylation\\nProfile 1&lt;/b&gt;\"))\n  \n  ## 2.2 Change link names ----\n  # Change link names and \n  lnks1_methylation_new &lt;- sankey_dat1[[\"links\"]] %&gt;%\n    mutate(\n      analysis = \"1_methylation\",\n      source = case_when(\n        source == names_clusters_1$name_og[1] ~ names_clusters_1$name_new[1],\n        source == names_clusters_1$name_og[2] ~ names_clusters_1$name_new[2],\n        TRUE ~ source),\n      target = case_when(\n        target == names_clusters_1$name_og[1] ~ names_clusters_1$name_new[1],\n        target == names_clusters_1$name_og[2] ~ names_clusters_1$name_new[2],\n        TRUE ~ target)) %&gt;%\n    filter(target != \"outcome\")\n  \n  ## 2.3 Change node names ----\n  # first, change latent cluster names to analysis specific cluster names\n  nodes1_methylation_new &lt;- sankey_dat1[[\"nodes\"]] %&gt;%\n    mutate(\n      name = case_when(\n        name == names_clusters_1$name_og[1] ~ names_clusters_1$name_new[1],\n        name == names_clusters_1$name_og[2] ~ names_clusters_1$name_new[2],\n        TRUE ~ name), \n      group = if_else(group == \"biomarker\", \"CpG\", as.character(group))) %&gt;%\n    filter(group != \"outcome\")\n  \n  \n  # Visualize\n  # sankeyNetwork(\n  #   Links = lnks1_methylation_new,\n  #   Nodes = nodes1_methylation_new,\n  #   Source = \"IDsource\", Target = \"IDtarget\",\n  #   Value = \"value\", NodeID = \"name\", LinkGroup = \"group\", NodeGroup = \"group\",\n  #   sinksRight = FALSE)\n  \n  \n  # 3. Modify analysis 2 ----\n  # For analysis 2, latent clusters need to be renamed to names from analysis 3:\n  ## 3.1 Get new and og latent cluster names ----\n  names_clusters_2 &lt;- data.frame(\n    name_og = c(\"Latent Cluster1\", \"Latent Cluster2\"), \n    name_new = c(\"&lt;b&gt;miRNA\\nProfile 0&lt;/b&gt;\", \"&lt;b&gt;miRNA\\nProfile 1&lt;/b&gt;\"))\n  \n  ## 3.2 Change cluster names ----\n  lnks2_miRNA_new &lt;- sankey_dat2[[\"links\"]] %&gt;% \n    mutate(\n      analysis = \"2_miRNA\", \n      source = case_when(\n        source == names_clusters_2$name_og[1] ~ names_clusters_2$name_new[1], \n        source == names_clusters_2$name_og[2] ~ names_clusters_2$name_new[2], \n        TRUE ~ source), \n      target = case_when(\n        target == names_clusters_2$name_og[1] ~ names_clusters_2$name_new[1], \n        target == names_clusters_2$name_og[2] ~ names_clusters_2$name_new[2], \n        TRUE ~ target)) %&gt;%\n    filter(target != \"outcome\")\n  \n  ## 3.3 Change node names ----\n  nodes2_miRNA_new &lt;- sankey_dat2[[\"nodes\"]] %&gt;% \n    mutate(\n      name = case_when(\n        name == names_clusters_2$name_og[1] ~ names_clusters_2$name_new[1], \n        name == names_clusters_2$name_og[2] ~ names_clusters_2$name_new[2], \n        TRUE ~ name), \n      group = case_when(group == \"exposure\" ~ \"lc\", \n                        group == \"biomarker\" ~ \"miRNA\",\n                        TRUE ~ as.character(group))) %&gt;%\n    filter(name != \"outcome\")\n  \n  # Visualize\n  # sankeyNetwork(\n  #   Links = lnks2_transcript_new, \n  #   Nodes = nodes2_transcript_new,\n  #   Source = \"IDsource\", Target = \"IDtarget\",\n  #   Value = \"value\", NodeID = \"name\", \n  #   LinkGroup = \"group\", NodeGroup = \"group\",\n  #   sinksRight = FALSE)\n  ##\n  \n  # 4. Modify analysis 3 ----\n  # For analysis 2, latent clusters need to be renamed to names from analysis 3:\n  ## 4.1 Get new and og latent cluster names ----\n  names_clusters_3 &lt;- tibble(\n    name_og = c(\"Latent Cluster1\", \"Latent Cluster2\"),\n    name_new = c(\"&lt;b&gt;Transcriptome\\nProfile 0&lt;/b&gt;\", \"&lt;b&gt;Transcriptome\\nProfile 1&lt;/b&gt;\")) \n  \n  \n  ## 4.2 Change cluster names ----\n  lnks3_transcript_new &lt;- sankey_dat3[[\"links\"]] %&gt;% \n    mutate(\n      analysis = \"3_transcript\", \n      source = case_when(\n        source == names_clusters_3$name_og[1] ~ names_clusters_3$name_new[1], \n        source == names_clusters_3$name_og[2] ~ names_clusters_3$name_new[2], \n        TRUE ~ source), \n      target = case_when(\n        target == names_clusters_3$name_og[1] ~ names_clusters_3$name_new[1], \n        target == names_clusters_3$name_og[2] ~ names_clusters_3$name_new[2], \n        TRUE ~ target))\n  \n  ## 4.3 Change node names ----\n  nodes3_transcript_new &lt;- sankey_dat3[[\"nodes\"]] %&gt;% \n    mutate(\n      name = case_when(\n        name == names_clusters_3$name_og[1] ~ names_clusters_3$name_new[1], \n        name == names_clusters_3$name_og[2] ~ names_clusters_3$name_new[2], \n        TRUE ~ name), \n      group = case_when(group == \"exposure\" ~ \"lc\", \n                        group == \"biomarker\" ~ \"TC\",\n                        TRUE ~ as.character(group)))\n  \n  # Test/Visualize\n  # sankeyNetwork(\n  #   Links = lnks3_protein_new, \n  #   Nodes = nodes3_protein_new,\n  #   Source = \"IDsource\", Target = \"IDtarget\",\n  #   Value = \"value\", NodeID = \"name\", LinkGroup = \"group\", NodeGroup = \"group\",\n  #   sinksRight = FALSE)\n  \n  \n  \n  # 5. Combine analysis 1-3 ----\n  \n  ## 5.1 Final Links ----\n  links_all_1 &lt;- bind_rows(lnks1_methylation_new, \n                           lnks2_miRNA_new,\n                           lnks3_transcript_new) %&gt;%\n    dplyr::select(-IDsource, -IDtarget)\n  \n  \n  ### 5.1.1 Arrange by magnitude ----\n  omics_priority &lt;- links_all_1 %&gt;% \n    filter(str_detect(source, \"Profile 0\"), \n           str_detect(target, \"Profile 0\", negate = TRUE), \n           str_detect(target, \"Profile 1\", negate = TRUE), \n           str_detect(target, \"outcome\", negate = TRUE)) %&gt;%\n    group_by(source) %&gt;%\n    arrange(desc(group), desc(value), .by_group = TRUE) %&gt;%\n    mutate(omics_order = row_number()) %&gt;%\n    ungroup() %&gt;%\n    dplyr::select(target, omics_order)\n  \n  \n  \n  links_all &lt;- links_all_1 %&gt;%\n    left_join(omics_priority) %&gt;%\n    mutate(\n      # arrange_me = if_else(is.na(omics_order), \n      #                           \"dont_arrange\", \n      #                           \"arrange\"), \n      row_num = row_number(), \n      # row_num_order_comb = if_else(is.na(omics_order), \n      #                              row_num, \n      #                              omics_order), \n      row_num_to_add = if_else(is.na(omics_order), \n                               as.numeric(row_num), \n                               NA_real_) %&gt;%\n        zoo::na.locf(),\n      order = if_else(is.na(omics_order), \n                      row_num_to_add, \n                      row_num_to_add+omics_order)\n    ) %&gt;%\n    arrange(order)\n  \n  \n  ### 5.1.2 Get new source and target IDs ----\n  # First, combine all layers, get unique identifier\n  node_ids &lt;- tibble(name = unique(c(unique(links_all$source), \n                                     unique(links_all$target)))) %&gt;%\n    mutate(ID = row_number()-1)\n  \n  # Then combine with original data \n  links_new &lt;- links_all %&gt;%\n    left_join(node_ids, by = c(\"source\" = \"name\")) %&gt;%\n    dplyr::rename(IDsource = ID) %&gt;%\n    left_join(node_ids, by = c(\"target\" = \"name\")) %&gt;%\n    dplyr::rename(IDtarget = ID)\n  \n  \n  ## 5.2 Final Nodes ----\n  nodes_new &lt;- node_ids %&gt;%\n    dplyr::select(name) %&gt;%\n    left_join(bind_rows(nodes1_methylation_new, \n                        nodes2_miRNA_new,\n                        nodes3_transcript_new))\n  # remove duplicates \n  nodes_new_nodup &lt;- nodes_new[!base::duplicated(nodes_new),] %&gt;%\n    base::as.data.frame()\n  \n  \n  # 6. Plotly Version ----\n  library(plotly)\n  \n  # Add color scheme to nodes\n  nodes_new_plotly &lt;- nodes_new_nodup %&gt;% \n    left_join(color_pal_sankey) %&gt;%\n    mutate(\n      x = case_when(\n        group == \"exposure\" ~ 0,\n        str_detect(name, \"Methylation\") ~ 1/5, \n        str_detect(name, \"miRNA\") | \n          str_detect(group, \"CpG\") ~ 2/5, \n        str_detect(name, \"Transcriptome\") | \n          str_detect(group, \"miRNA\") ~ 3/5, \n        str_detect(group, \"TC\") ~  4/5, \n        str_detect(group, \"outcome\") ~ 4.5/5, \n      ))\n  \n  \n  ## 6.2 Get links for Plotly, set color ----\n  links_new &lt;- links_new  %&gt;%\n    mutate(\n      link_color = case_when(\n        # Ref link color\n        value == 0 ~     \"#f3f6f4\", \n        # Methylation \n        str_detect(target, \"outcome\") &  group == TRUE  ~  \"red\",\n        \n        str_detect(source, \"Transcriptome\") &  group == TRUE  ~  \"#bf9000\",\n        str_detect(source, \"Transcriptome\") &  group == FALSE ~  \"#ffd966\",\n        # Transcriptome\n        str_detect(source, \"Methylation\") &  group == TRUE  ~  \"#38761d\",\n        str_detect(source, \"Methylation\") &  group == FALSE ~  \"#b6d7a8\",\n        # proteome\n        str_detect(source, \"miRNA\") &  group == TRUE  ~  \"#a64d79\",\n        str_detect(source, \"miRNA\") &  group == FALSE ~  \"#ead1dc\",\n        \n        links_new$group == FALSE ~ \"#d9d2e9\", # Negative association\n        links_new$group == TRUE ~  \"red\")) # Positive association\n  \n  plotly_link &lt;- list(\n    source = links_new$IDsource,\n    target = links_new$IDtarget,\n    value = links_new$value+.00000000000000000000001, \n    color = links_new$link_color)  \n  \n  \n  # Get list of nodes for Plotly\n  plotly_node &lt;- list(\n    label = nodes_new_plotly$name, \n    color = nodes_new_plotly$color,\n    pad = 15,\n    thickness = 20,\n    line = list(color = \"black\",width = 0.5), \n    x = nodes_new_plotly$x, \n    y = c(0.01, \n          0.1, 0.3, # Methylation clusters\n          .45, .55, # Transcriptome clusters\n          .80, .95, # Proteome clusters\n          seq(from = .01, to = 1, by = 0.035)[1:n_omics_1], # Cpgs (10 total)\n          seq(from = 0.35, to = 1, by = 0.025)[1:n_omics_2], # miRNA (8 total)\n          seq(from = 0.75, to = 1, by = 0.03)[1:n_omics_3], # Transcript (10 total)\n          .95\n    ))\n  \n  \n  ## 6.3 Plot Figure ----\n  fig &lt;- plot_ly(\n    type = \"sankey\",\n    domain = list(\n      x =  c(0,1),\n      y =  c(0,1)),\n    orientation = \"h\",\n    node = plotly_node,\n    link = plotly_link)\n  \n  (fig &lt;- fig %&gt;% layout(\n    # title = \"Basic Sankey Diagram\",\n    font = list(\n      size = text_size\n    ))\n  )\n  \n  return(fig)\n}\n\n\n\n\n6.1.4 Plot Omics Profile\n\n\nCode\n#' Plot of Omics profiles for each cluster using LUCID\n#' \n#' Given an object of class from LUCID\n#'\n#' @param fit an object of class from LUCID\n#' @param integration_type type of integration, \"Early\" or \"Intermediate\"\n#'\n#' @return a figure of Omics profiles for each cluster using LUCID\n#'\n#' @import dplyr\n#' @importFrom ggplot2 ggplot\n#' \nplot_omics_profiles &lt;- function(fit, integration_type, omics_lst_data) {\n  \n  # Combines omics data into one dataframe\n  omics_lst_df &lt;- purrr::map(omics_lst_data, ~tibble::as_tibble(.x, rownames = \"name\"))\n  \n  # Get metadata file\n  meta_df &lt;- imap_dfr(omics_lst_df,\n                      ~tibble(omic_layer = .y, ftr_name = names(.x))) |&gt;\n    filter(ftr_name != \"name\") |&gt;\n    mutate(omic_num = case_when(str_detect(omic_layer, \"meth\") ~ 1,\n                                str_detect(omic_layer, \"transc\") ~ 2,\n                                str_detect(omic_layer, \"miR\") ~ 3,\n                                str_detect(omic_layer, \"pro\") ~ 4,\n                                str_detect(omic_layer, \"met\") ~ 5))\n  \n  if(integration_type == \"Early\"){\n    M_mean = as.data.frame(fit$res_Mu)\n    M_mean$cluster = as.factor(1:2)\n    # Reshape the data\n    M_mean_melt &lt;- M_mean %&gt;% \n      pivot_longer(cols = -cluster, names_to = \"variable\", values_to = \"value\")\n    \n    M_mean_melt &lt;- M_mean_melt %&gt;% \n      mutate(cluster = paste0(\"Cluster \", cluster))\n    # add color label for omics layer\n    M_mean_melt = M_mean_melt %&gt;%\n      mutate(color_label = case_when(str_detect(variable,  \"cg\") ~ \"1\", \n                                     str_detect(variable, \"tc\") ~ \"2\", \n                                     TRUE ~ \"3\"))\n    \n    fig &lt;- ggplot(M_mean_melt, \n                  aes(fill = color_label, y = value, x = variable)) +\n      geom_bar(position=\"dodge\", stat=\"identity\") +\n      ggtitle(\"Omics profiles for the two latent clusters\") +\n      facet_grid(rows = vars(cluster), scales = \"free_y\") +\n      theme(legend.position=\"none\") +\n      geom_hline(yintercept = 0) +\n      xlab(\"\") +\n      theme(text = element_text(size=10),\n            axis.text.x = element_text(angle = 90, vjust = 1,\n                                       hjust = 1),\n            plot.margin = margin(10, 10, 10, 80),\n            panel.background = element_rect(fill=\"white\"), \n            strip.background = element_rect(fill = \"white\"),\n            axis.line.x = element_line(color = \"black\"),\n            axis.line.y = element_line(color = \"black\"),) +\n      scale_fill_manual(values = c(\"#2fa4da\", \"#A77E69\", \"#e7b6c1\"))\n  } else if(integration_type == \"Intermediate\"){\n    M_mean = as_tibble(fit$res_Mu[[1]], rownames = \"variable\") %&gt;%\n      bind_rows(as_tibble(fit$res_Mu[[2]], rownames = \"variable\")) %&gt;%\n      bind_rows(as_tibble(fit$res_Mu[[3]], rownames = \"variable\"))\n    \n    # Reorder results because mirna order is reversed\n    M_mean1 &lt;- M_mean %&gt;% \n      left_join(meta_df, by = c(\"variable\" = \"ftr_name\")) %&gt;%\n      mutate(`Low Risk`  =  if_else(omic_layer == \"miRna\", V2, V1), \n             `High Risk` =  if_else(omic_layer == \"miRna\", V1, V2)) %&gt;%\n      dplyr::select(-c(\"V1\", \"V2\"))\n    \n    # Pivot longer for figure \n    M_mean_l &lt;- M_mean1 %&gt;% \n      pivot_longer(cols = c(`Low Risk`, `High Risk`),\n                   names_to = \"cluster\",\n                   values_to = \"value\")\n    \n    # add color label for omics layer\n    M_mean2 = M_mean_l %&gt;%\n      mutate(color_label = case_when(omic_layer == \"methylome\" ~ \"1\", \n                                     omic_layer == \"transcriptome\" ~ \"2\", \n                                     omic_layer == \"miRna\" ~ \"3\"), \n             low_high = if_else(str_detect(cluster, \"Low\"), 0,1),\n             omic = if_else(omic_layer == \"miRna\", \n                            \"miR\",\n                            str_sub(omic_layer, end = 1) %&gt;% toupper()),\n             omic_cluster = str_c(omic, low_high))\n    \n    # Filter only the top ## differential expressed features \n    M_mean2_top &lt;- M_mean2 %&gt;% \n      group_by(variable) %&gt;% \n      filter(abs(value) == max(abs(value))) %&gt;% \n      ungroup() %&gt;% \n      arrange(max(abs(value))) %&gt;% \n      group_by(omic_layer) %&gt;% \n      slice_head(n=12) %&gt;%\n      ungroup()\n    \n    # Plots top 12 features\n    fig &lt;- ggplot(M_mean2  %&gt;% filter(variable %in% M_mean2_top$variable),\n                  aes(fill = color_label, y = value, x = variable)) +\n      geom_bar(position=\"dodge\", stat=\"identity\") +\n      ggtitle(\"Omics profiles for 2 latent clusters - Lucid in Parallel\") +\n      facet_grid(rows = vars(cluster),\n                 cols = vars(omic_layer), scales = \"free_x\", space = \"free\") +\n      theme(legend.position=\"none\") +\n      geom_hline(yintercept = 0) +\n      xlab(\"\") +\n      theme(text = element_text(size=10),\n            axis.text.x = element_text(angle = 90, vjust = 1,\n                                       hjust = 1),\n            plot.margin = margin(10, 10, 10, 80),\n            panel.background = element_rect(fill=\"white\"),\n            strip.background = element_rect(fill = \"white\"),\n            axis.line.x = element_line(color = \"black\"),\n            axis.line.y = element_line(color = \"black\"),) +\n      scale_fill_manual(values = c(\"#2fa4da\", \"#A77E69\", \"#e7b6c1\"))\n  }\n  \n  return(fig)\n}\n\n\n\n\n6.1.5 Change the Reference Cluster for Different LUCID Models\n\n\nCode\n#' reorder cluster estimated from LUCID\n#'\n#' @param model a model returned the function lucid\n#' @param order the desired order of the cluster label. For example, if 2 clusters\n#' are estiamted and you want to flip the cluster label, you should input c(2, 1).\n#' The first element will be used as the reference cluster\n#'\nreorder_lucid &lt;- function(model,\n                          order) {\n  # record parameters \n  pars &lt;- model$pars\n  beta &lt;- pars$beta\n  mu &lt;- pars$mu\n  sigma &lt;- pars$sigma\n  gamma &lt;- pars$gamma\n  K &lt;- model$K\n  \n  # 1 - reorder exposure effect\n  # use the estimate from the \n  ref_cluster &lt;- order[1]\n  beta &lt;- t(t(beta) - beta[ref_cluster, ])[order, ]\n  \n  # 2 - reorder omic effect\n  mu &lt;- mu[order, ]\n  var &lt;- vector(mode = \"list\", length = K)\n  for (i in 1:K) {\n    var[[i]] &lt;- sigma[[order[i]]]\n  }\n  \n  # 3 - reorder outcome effect\n  gamma$beta[1:K] &lt;- gamma$beta[order]\n  gamma$sigma &lt;- gamma$sigma[order]\n  \n  model$pars &lt;- list(beta = beta,\n                     mu = mu,\n                     sigma = sigma,\n                     gamma = gamma)\n  \n  return(model)\n}\n\n# example ----\n# G &lt;- sim_data$G\n# Z &lt;- sim_data$Z\n# Y_normal &lt;- sim_data$Y_normal\n# cov &lt;- sim_data$Covariate\n# \n# # In this model, the exposure effect should be around 2\n# fit &lt;- lucid(G = G, Z = Z, Y = Y_normal, CoY = cov)\n# summary_lucid(fit)\n# flip the label of the 2 clusters, \n# which is equivalent to use the second cluster as the reference cluster\n# fit_reorder &lt;- reorder_lucid(model = fit,\n#                              order = c(2, 1))\n# the exposure effect should be around 1/2\n\n\n#' 2. change variable name in the sankey diagram ------------------\n#' @title Visualize LUCID model through a Sankey diagram\n#' @description In the Sankey diagram, each node either represents a variable (exposure,\n#' omics or outcome) or a latent cluster. Each line represents an association. The\n#' color of the node represents variable type, either exposure, omics or outcome.\n#' The width of the line represents the effect size of a certain association; the\n#' color of the line represents the direction of a certain association. \n#' \n#' @param x A LUCID model fitted by \\code{\\link{est_lucid}}\n#' @param G_color Color of node for exposure\n#' @param X_color Color of node for latent cluster\n#' @param Z_color Color of node for omics data\n#' @param G_name variable name for latent exposure variables\n#' @param Z_name variable name for omic features\n#' @param pos_link_color Color of link corresponds to positive association\n#' @param neg_link_color Color of link corresponds to negative association\n#' @param fontsize Font size for annotation\n#' \n#' @return A DAG graph created by \\code{\\link{sankeyNetwork}}\n#' \n\nplot_lucid_without_outcome &lt;- function(x,\n                       G_color = \"dimgray\",\n                       X_color = \"#eb8c30\",\n                       Z_color = \"#2fa4da\",\n                       G_name = NULL,\n                       Z_name = NULL,\n                       pos_link_color = \"#67928b\",\n                       neg_link_color = \"#d1e5eb\",\n                       fontsize = 7\n) {\n  K &lt;- x$K\n  var.names &lt;- x$var.names\n  pars &lt;- x$pars\n  dimG &lt;- length(var.names$Gnames)\n  dimZ &lt;- length(var.names$Znames)\n  valueGtoX &lt;- as.vector(t(x$pars$beta[, -1]))\n  valueXtoZ &lt;- as.vector(t(x$pars$mu))\n  # valueXtoY &lt;- as.vector(x$pars$gamma$beta)[1:K]\n  if(is.null(G_name)) {\n    G_name = x$var.names$Gnames\n  }\n  GtoX &lt;- data.frame(source = rep(G_name, K),\n                     target = paste0(\"Latent Cluster\", as.vector(sapply(1:K, function(x) rep(x, dimG)))),\n                     value = abs(valueGtoX),\n                     group = as.factor(valueGtoX &gt; 0))\n  if(is.null(Z_name)) {\n    Z_name = var.names$Znames\n  }\n  XtoZ &lt;- data.frame(source = paste0(\"Latent Cluster\", as.vector(sapply(1:K, function(x) rep(x, dimZ)))),\n                     target = rep(Z_name, K),\n                     value = abs(valueXtoZ),\n                     group = as.factor(valueXtoZ &gt; 0))\n  # if(is.null(Y_name)) {\n  #   Y_name = var.names$Ynames\n  # }\n  # XtoY &lt;- data.frame(source = paste0(\"Latent Cluster\", 1:K),\n  #                    target = rep(Y_name, K),\n  #                    value = abs(valueXtoY),\n  #                    group = as.factor(valueXtoY &gt; 0))\n\n  links &lt;- rbind(GtoX, XtoZ) #, XtoY\n  nodes &lt;- data.frame(name = unique(c(as.character(links$source), as.character(links$target))),\n                      group = as.factor(c(rep(\"exposure\", dimG), \n                                          rep(\"lc\", K), \n                                          rep(\"biomarker\", dimZ))))\n  links$IDsource &lt;- match(links$source, nodes$name)-1 \n  links$IDtarget &lt;- match(links$target, nodes$name)-1 \n  color_scale &lt;- data.frame(domain = c(\"exposure\", \"lc\", \"biomarker\", \"TRUE\", \"FALSE\"),\n                            range = c(G_color, X_color, Z_color, pos_link_color, neg_link_color))\n  \n  p &lt;- sankeyNetwork(Links = links, \n                     Nodes = nodes,\n                     Source = \"IDsource\", \n                     Target = \"IDtarget\",\n                     Value = \"value\", \n                     NodeID = \"name\",\n                     colourScale = JS(\n                       sprintf(\n                         'd3.scaleOrdinal()\n                        .domain(%s)\n                        .range(%s)\n                       ',\n                       jsonlite::toJSON(color_scale$domain),\n                       jsonlite::toJSON(color_scale$range)\n                       )), \n                     LinkGroup =\"group\", \n                     NodeGroup =\"group\",\n                     sinksRight = FALSE, \n                     fontSize = fontsize)\n  p\n}\n\n# example\n# plot_lucid(fit)\n# plot_lucid_without_outcome(fit)\n# # you can also re-name exposure names and the omic feature name\n# plot_lucid_without_outcome(fit,\n#            G_name = paste0(\"PFAS_\", 1:10))\n\n\n#' reorder LUCID in Parallel model by specifying reference cluster ------------\n# note: only works for K = 2 in each omic layer\n# reference = c(1,1,2)\n# lucidus_fit &lt;- fit_reordered\nreorder_lucid_parallel &lt;- function(lucidus_fit,\n                                   reference = NULL) {\n  if(is.null(reference)) {\n    warning(\"no reference specified, return the original model\")\n    return(lucidus_fit)\n  }\n  \n  n_omic &lt;- length(reference)\n  \n  # reorder beta\n  GtoX &lt;- lucidus_fit$res_Beta$Beta\n  lucidus_fit$res_Beta$Beta &lt;- lapply(1:n_omic, function(i) {\n    (-1)^(reference[i] - 1) * GtoX[[i]] # if reference = 1, no changes; \n    # if reference = 2, flip the reference and negate the estimates\n  })\n  # reorder mu\n  XtoZ &lt;- lucidus_fit$res_Mu\n  lucidus_fit$res_Mu &lt;- lapply(1:n_omic, function(i) {\n    x &lt;- c(1, 2) # order of clusters\n    if(reference[i] == 2) {\n      x &lt;- c(2, 1)\n      XtoZ[[i]][, x]\n    } else{\n      XtoZ[[i]][, x]\n    }\n  }) \n  # reorder gamma\n  XtoY &lt;- lucidus_fit$res_Gamma$Gamma$mu\n  XtoY[1] &lt;- XtoY[1] + sum(XtoY[-1] * (reference - 1)) # reference level using the new reference\n  XtoY[-1] &lt;- (-1)^(reference - 1) * XtoY[-1] # if reference = 2, flip the estimates\n  lucidus_fit$res_Gamma$Gamma$mu &lt;- XtoY\n  lucidus_fit$res_Gamma$fit$coefficients &lt;- XtoY\n  \n  # return the object using the new reference\n  return(lucidus_fit)\n}"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "He, Jingxuan, and Chubing Zeng. 2023. “Xtune: Regularized\nRegression with Feature-Specific Penalties Integrating External\nInformation.” Computer Program. https://github.com/JingxuanH/xtune.\n\n\nLock, E. F., K. A. Hoadley, J. S. Marron, and A. B. Nobel. 2013.\n“JOINT AND INDIVIDUAL VARIATION EXPLAINED (JIVE) FOR INTEGRATED\nANALYSIS OF MULTIPLE DATA TYPES.” Journal Article. Ann Appl\nStat 7 (1): 523–42. https://doi.org/10.1214/12-aoas597.\n\n\nPeng, C., J. Wang, I. Asante, S. Louie, R. Jin, L. Chatzi, G. Casey, D.\nC. Thomas, and D. V. Conti. 2020. “A Latent Unknown Clustering\nIntegrating Multi-Omics Data (LUCID) with Phenotypic Traits.”\nJournal Article. Bioinformatics 36 (3): 842–50. https://doi.org/10.1093/bioinformatics/btz667.\n\n\nTofighi, D., and D. P. MacKinnon. 2011. “RMediation: An r Package\nfor Mediation Analysis Confidence Intervals.” Journal Article.\nBehav Res Methods 43 (3): 692–700. https://doi.org/10.3758/s13428-011-0076-x.\n\n\nVrijheid, Martine, Rémy Slama, Oliver Robinson, Leda Chatzi, Muireann\nCoen, Peter van den Hazel, Cathrine Thomsen, et al. 2014. “The\nHuman Early-Life Exposome (HELIX): Project Rationale and Design.”\nJournal Article. Environmental Health Perspectives 122 (6):\n535–44. https://doi.org/10.1289/ehp.1307204.\n\n\nZeng, C., D. C. Thomas, and J. P. Lewinger. 2021. “Incorporating\nPrior Knowledge into Regularized Regression.” Journal Article.\nBioinformatics 37 (4): 514–21. https://doi.org/10.1093/bioinformatics/btaa776.\n\n\nZhang, H., Y. Zheng, Z. Zhang, T. Gao, B. Joyce, G. Yoon, W. Zhang, et\nal. 2016. “Estimating and Testing High-Dimensional Mediation\nEffects in Epigenetic Studies.” Journal Article.\nBioinformatics 32 (20): 3150–54. https://doi.org/10.1093/bioinformatics/btw351."
  }
]